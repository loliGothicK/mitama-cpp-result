{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Mitama.Result is a header only C++17 library for error handling. Prerequisites and installation \u00b6 Prerequisites \u00b6 Compiler/Toolchain Status clang >= 7.0.0 Testing on CircleCI; tested on each push to GitHub gcc >= 8.3.0 Testing on CircleCI; tested on each push to GitHub boost >= 1.67.0 Testing on CircleCI; tested on each push to GitHub More specifically, Mitama.Result requires a compiler/standard library supporting the following C++17 features: constexpr if constexpr lambda inline variables fold expressions class template deduction and deduction guide All the C++17 type traits from the <type_traits> header std::{invoke, apply} from the <functional> header std::string_view from the <string_view> header std::monostate from the <variant> header And requires a Boost supporting the following libraries: boost::format from the <boost/format.hpp> header boost::hana::{fix, overload, overload_linearly} from the <boost/hana/functional/{fix, overload, overload_linearly}.hpp> header Installation \u00b6 CMake \u00b6 First, clone mitama-cpp-result repository. $ git clone https://github.com/LoliGothick/mitama-cpp-result.git Second, run CMake and Make commands: $ cd mitama-cpp-result $ cmake .. $ make install Manually \u00b6 First, clone mitama-cpp-result repository. $ git clone https://github.com/LoliGothick/mitama-cpp-result.git Second, add path/to/mitama-cpp/include to include path. Basic Usage \u00b6 Here is a bad code. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); If this program fail to assert, you don't know the reason for the error. Rewrite this code using result. auto func ( int a ) -> mitama :: result < int , std :: string > { if ( first check ) return mitama :: failure ( \"first check failed\" ); // early return if ( second check ) return mitama :: failure ( \"second check failed\" ); // early return if ( third check ) return mitama :: failure ( \"third check failed\" ); // early return // function body... return mitama :: success ( 42 ); } // ... int value = func ( 42 ). unwrap (); Even if this program fail to assert, you can get the reason for the error.","title":"Home"},{"location":"#introduction","text":"Mitama.Result is a header only C++17 library for error handling.","title":"Introduction"},{"location":"#prerequisites_and_installation","text":"","title":"Prerequisites and installation"},{"location":"#prerequisites","text":"Compiler/Toolchain Status clang >= 7.0.0 Testing on CircleCI; tested on each push to GitHub gcc >= 8.3.0 Testing on CircleCI; tested on each push to GitHub boost >= 1.67.0 Testing on CircleCI; tested on each push to GitHub More specifically, Mitama.Result requires a compiler/standard library supporting the following C++17 features: constexpr if constexpr lambda inline variables fold expressions class template deduction and deduction guide All the C++17 type traits from the <type_traits> header std::{invoke, apply} from the <functional> header std::string_view from the <string_view> header std::monostate from the <variant> header And requires a Boost supporting the following libraries: boost::format from the <boost/format.hpp> header boost::hana::{fix, overload, overload_linearly} from the <boost/hana/functional/{fix, overload, overload_linearly}.hpp> header","title":"Prerequisites"},{"location":"#installation","text":"","title":"Installation"},{"location":"#cmake","text":"First, clone mitama-cpp-result repository. $ git clone https://github.com/LoliGothick/mitama-cpp-result.git Second, run CMake and Make commands: $ cd mitama-cpp-result $ cmake .. $ make install","title":"CMake"},{"location":"#manually","text":"First, clone mitama-cpp-result repository. $ git clone https://github.com/LoliGothick/mitama-cpp-result.git Second, add path/to/mitama-cpp/include to include path.","title":"Manually"},{"location":"#basic_usage","text":"Here is a bad code. bool func ( int a ) { if ( first check ) return false ; if ( second check ) return false ; if ( third check ) return false ; // function body... return true ; } // ... assert ( func ( 42 )); If this program fail to assert, you don't know the reason for the error. Rewrite this code using result. auto func ( int a ) -> mitama :: result < int , std :: string > { if ( first check ) return mitama :: failure ( \"first check failed\" ); // early return if ( second check ) return mitama :: failure ( \"second check failed\" ); // early return if ( third check ) return mitama :: failure ( \"third check failed\" ); // early return // function body... return mitama :: success ( 42 ); } // ... int value = func ( 42 ). unwrap (); Even if this program fail to assert, you can get the reason for the error.","title":"Basic Usage"},{"location":"anyhow/anyhow/","text":"anyhow 101 \u00b6 Basic Concepts \u00b6 anyhow is a library that can reduce the cost of writing error handling by treating error types as shared_ptr of a common base type. namespace mitama :: anyhow { // common base type for errors struct error { virtual std :: string what () const = 0 ; }; // an alias template for anyhow template < class T > using result = result < void_to_monostate_t < T > , std :: shared_ptr <:: mitama :: anyhow :: error >> ; } Examples: In the first example, we replace mitama::result with anyhow::result . // begin example #include <mitama/result/result.hpp> #include <mitama/anyhow/anyhow.hpp> namespace anyhow = mitama :: anyhow ; int main () { anyhow :: result < int > res = mitama :: success ( 1 ); } In the second example, we make a error with anyhow::anyhow . anyhow::anyhow creates std::shared_ptr<anyhow::cause<T>> from a given argument type of T . An expression mitama::failure(anyhow::anyhow(\"error \"s)) can be converted to anyhow::result since anyhow::cause inherits from anyhow::error . // begin example #include <mitama/result/result.hpp> #include <mitama/anyhow/anyhow.hpp> namespace anyhow = mitama :: anyhow ; using namespace std :: literals :: string_literals ; int main () { anyhow :: result < int > res = mitama :: failure ( anyhow :: anyhow ( \"error\" s )); } Error Chaining \u00b6 By chaining errors, you can track where and how the error occurred, with a reason. Use the anyhow::errors class for error chaining. anyhow::errors has two parts: the error itself and its context. namespace mitama :: anyhow { class errors : public error { std :: shared_ptr < error > src_ ; std :: shared_ptr < error > ctx_ ; public : // constructors std :: string what () const override { std :: stringstream ss ; ss << \"cause: \" << ctx_ -> what () << ' ' << \"source: \" << src_ -> what (); return ss . str (); } }; } You can chaining error with mitama::result::with_context() . // begin example #include <mitama/result/result.hpp> #include <mitama/result/result_io.hpp> #include <mitama/anyhow/anyhow.hpp> namespace anyhow = mitama :: anyhow ; using namespace std :: literals :: string_literals ; struct database_t {}; // dummy auto connect_to_db () -> anyhow :: result < database_t > { return mitama :: failure ( anyhow :: anyhow ( \"Failed to connect to the database.\" s )); } auto read_db () -> anyhow :: result < int > { auto conn = connect_to_db (); return conn . map ([] ( auto const & ) { // read the database and returns value return 42 ; }). with_context ([] { return anyhow :: anyhow ( \"Failed to read the database.\" ); }); } int main () { auto res = read_db (); std :: cout << res << std :: endl ; // outputs: // failure(cause: Failed to read the database. source: Failed to connect to the database.) }","title":"anyhow 101"},{"location":"anyhow/anyhow/#anyhow_101","text":"","title":"anyhow 101"},{"location":"anyhow/anyhow/#basic_concepts","text":"anyhow is a library that can reduce the cost of writing error handling by treating error types as shared_ptr of a common base type. namespace mitama :: anyhow { // common base type for errors struct error { virtual std :: string what () const = 0 ; }; // an alias template for anyhow template < class T > using result = result < void_to_monostate_t < T > , std :: shared_ptr <:: mitama :: anyhow :: error >> ; } Examples: In the first example, we replace mitama::result with anyhow::result . // begin example #include <mitama/result/result.hpp> #include <mitama/anyhow/anyhow.hpp> namespace anyhow = mitama :: anyhow ; int main () { anyhow :: result < int > res = mitama :: success ( 1 ); } In the second example, we make a error with anyhow::anyhow . anyhow::anyhow creates std::shared_ptr<anyhow::cause<T>> from a given argument type of T . An expression mitama::failure(anyhow::anyhow(\"error \"s)) can be converted to anyhow::result since anyhow::cause inherits from anyhow::error . // begin example #include <mitama/result/result.hpp> #include <mitama/anyhow/anyhow.hpp> namespace anyhow = mitama :: anyhow ; using namespace std :: literals :: string_literals ; int main () { anyhow :: result < int > res = mitama :: failure ( anyhow :: anyhow ( \"error\" s )); }","title":"Basic Concepts"},{"location":"anyhow/anyhow/#error_chaining","text":"By chaining errors, you can track where and how the error occurred, with a reason. Use the anyhow::errors class for error chaining. anyhow::errors has two parts: the error itself and its context. namespace mitama :: anyhow { class errors : public error { std :: shared_ptr < error > src_ ; std :: shared_ptr < error > ctx_ ; public : // constructors std :: string what () const override { std :: stringstream ss ; ss << \"cause: \" << ctx_ -> what () << ' ' << \"source: \" << src_ -> what (); return ss . str (); } }; } You can chaining error with mitama::result::with_context() . // begin example #include <mitama/result/result.hpp> #include <mitama/result/result_io.hpp> #include <mitama/anyhow/anyhow.hpp> namespace anyhow = mitama :: anyhow ; using namespace std :: literals :: string_literals ; struct database_t {}; // dummy auto connect_to_db () -> anyhow :: result < database_t > { return mitama :: failure ( anyhow :: anyhow ( \"Failed to connect to the database.\" s )); } auto read_db () -> anyhow :: result < int > { auto conn = connect_to_db (); return conn . map ([] ( auto const & ) { // read the database and returns value return 42 ; }). with_context ([] { return anyhow :: anyhow ( \"Failed to read the database.\" ); }); } int main () { auto res = read_db (); std :: cout << res << std :: endl ; // outputs: // failure(cause: Failed to read the database. source: Failed to connect to the database.) }","title":"Error Chaining"},{"location":"maybe/APIs/","text":"API reference \u00b6 is_just \u00b6 maybe<T> \u2192 bool Returns true if the maybe has some value. declaration template < class T > class maybe { constexpr bool maybe < T >:: is_just () const noexcept ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( x . is_just () ); maybe < int > y = nothing ; assert ( not y . is_just () ); } // end example is_nothing \u00b6 maybe<T> \u2192 bool Returns true if the maybe is a nothing value. declarations template < class T > class maybe { constexpr bool maybe < T >:: is_nothing () const noexcept ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( ! x . is_nothing () ); maybe < int > y = nothing ; assert ( y . is_nothing () ); } // end example as_ref \u00b6 maybe<T>& \u2192 maybe<T&> Converts from maybe<T>& to maybe<T&> . declarations template < class T > class maybe { auto maybe < T >:: as_ref () & -> maybe < T &> ; auto maybe < T >:: as_ref () const & -> maybe < const T &> ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> #include <iostream> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe text = just ( \"Hello, world!\" s ); // First, cast `maybe<T>` to `maybe<T&>` with `as_ref`, auto text_length = text . as_ref (). map ( & std :: string :: size ); std :: cout << \"still can print text: \" << text << \" \\n \" ; } // end example expect \u00b6 maybe<T> \u2192 string_view \u2192 T Unwraps a maybe, yielding the content of a just . declarations template < class T > class maybe { auto maybe < T >:: expect ( std :: string_view msg ) $ { CVREF } -> T $ { CVREF } ; }; Exceptions Raise mitama::runtime_panic if the value is a nothing with a custom panic message provided by msg . Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"value\" s ); assert ( x . expect ( \"the world is ending\" ) == \"value\" s ); } try { maybe < int > x = nothing ; x . expect ( \"the world is ending\" ); // panics with `the world is ending` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'the world is ending' } } // end example unwrap \u00b6 maybe<T> \u2192 T Unwraps a maybe, yielding the content of a just . declarations template < class T > class maybe { auto maybe < T >:: unwrap () $ { CVREF } -> value_type $ { CVREF } ; }; Exceptions Raise mitama::runtime_panic if a maybe has not just value. Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"air\" s ); assert ( x . unwrap () == \"air\" s ); } try { maybe < int > x = nothing ; x . unwrap (); // raise an exception } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'called `maybe::unwrap()` on a `nothing` value' } } // end example unwrap_or \u00b6 maybe<T> \u2192 T \u2192 T Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. declarations template < class T > class maybe { template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < value_type $ { CVREF }, U &&>>:: value , std :: common_type_t < value_type $ { CVREF }, U &&>> maybe < T >:: unwrap_or ( U && def ) $ { CVREF } ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { assert ( maybe { just ( \"car\" s )}. unwrap_or ( \"bike\" s ) == \"car\" s ); assert ( maybe < std :: string > { nothing }. unwrap_or ( \"bike\" s ) == \"bike\" s ); } // end example unwrap_or_else \u00b6 maybe<T> \u2192 F \u2192 T Returns the contained value or computes it from a invocable object op: F . constraints requires ( F && f ) { { f () } -> std :: convertible_to < T > ; } declarations template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < value_type $ { CVREF }, std :: invoke_result_t < F &&>>>> , std :: common_type_t < value_type $ { CVREF }, std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) $ { CVREF } ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int k = 10 ; assert ( maybe { just ( 4 )}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 4 ); assert ( maybe < int > {}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 20 ); } // end example map \u00b6 maybe<T> \u2192 F \u2192 Args... \u2192 maybe<U> Maps a maybe<T> to maybe<U> by applying a function to a contained value. constraints requires { maybe < std :: invoke_result_t < F && , T , Args && ... >> ; } declarations template < class T > class maybe { template < class F , class ... Args , std :: enable_if_t < std :: is_invocable_v < F && , T $ { CVREF }, Args && ... > , bool > = false > auto maybe < T >:: map ( F && f , Args && ...) $ { CVREF } -> maybe < std :: invoke_result_t < F && , T $ { CVREF }, Args && ... >> ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe maybe_some_string = just ( \"Hello, World!\" s ); // `maybe::map` takes self *by ref*, // *not* consuming `maybe_some_string` maybe maybe_some_len = maybe_some_string . map ( & std :: string :: size ); assert ( maybe_some_len == just ( 13u )); } // end example map_or \u00b6 maybe<T> \u2192 U \u2192 F \u2192 Args... \u2192 U Applies a function to the contained value (if any), or returns the provided default (if not). declarations template < class T > class maybe { template < class U , class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , value_type $ { CVREF }, Args && ... > , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , value_type $ { CVREF } > >>> , std :: common_type_t < U && , std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... >>> map_or ( U && , F && , Args && ...) $ { CVREF }; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . map_or ( 42 , & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or ( 42 , & std :: string :: size ) == 42 ); } // end example map_or_else \u00b6 maybe<T> \u2192 D \u2192 F \u2192 Args... \u2192 U Applies a function to the contained value (if any), or computes a default (if not). constraints requires { maybe < std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T , Args && ... > > >> ; } declarations template < class D , class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , value_type $ { CVREF }, Args && ... > , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... > >>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... > >> map_or_else ( D && , F && , Args && ...) $ { CVREF }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { int k = 21 ; maybe x = just ( \"foo\" s ); assert ( x . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 42 ); } // end example ok_or \u00b6 maybe<T> \u2192 E [default=std::monostate] \u2192 result<T, E> Transforms the maybe<T> into a result<T, E> , mapping just(v) to success(v) and nothing to failure(err) . Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated. declarations template < class T > class maybe { template < class E = std :: monostate > auto maybe < T >:: ok_or ( E && err = {}) & -> result < T , std :: remove_reference_t < E >> ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or ( 0 ) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or ( 0 ) == failure ( 0 )); assert ( y . ok_or () == failure <> ()); } // end example ok_or_else \u00b6 maybe<T> \u2192 F \u2192 result<T, E> Transforms the maybe<T> into a result<T, E> , mapping just(v) to success(v) and nothing to failure(err()) . constraints requires { result < T , std :: invoke_result_t < F , Args ... >> } declarations template < class T > class maybe { template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < T , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or_else ([]{ return 0 ; }) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or_else ([]{ return 0 ; }) == failure ( 0 )); } // end example conj \u00b6 maybe<T> \u2192 maybe<U> \u2192 maybe<U> Returns nothing if the lhs is nothing , otherwise returns rhs . declarations template < class T > class maybe { template < class U > auto maybe < T >:: conj ( maybe < U > const & rhs ) -> maybe < U > ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } { maybe < int > x = nothing ; maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == nothing ); } { maybe x = just ( 2 ); maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == just ( \"foo\" s )); } { maybe < int > x = nothing ; maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } } // end example and_then \u00b6 maybe<T> \u2192 F \u2192 maybe<U> Returns nothing if the option is nothing , otherwise invokes f with the wrapped value and returns the result. Some languages call this operation flatmap. constraints requires ( is_maybe_v < std :: invoke_result_t < F && , T , Args ... >> ) declarations template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , value_type $ { CVREF }, Args && ... > , is_maybe < std :: decay_t < std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... >>>> , std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... >> and_then ( F && f , Args && ... args ) $ { CVREF } Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto sq = []( int x ) -> maybe < int > { return just ( x * x ); }; auto nope = [](...) -> maybe < int > { return nothing ; }; assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( sq ) == just ( 16 )); assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( nope ) == nothing ); assert ( maybe { just ( 2 )}. and_then ( nope ). and_then ( sq ) == nothing ); assert ( nope (). and_then ( sq ). and_then ( sq ) == nothing ); } // end example filter \u00b6 maybe<T> \u2192 Pred \u2192 maybe<T> Returns nothing if the option is nothing , otherwise invokes predicate with the wrapped value and returns: just(t) if predicate returns true (where t is the wrapped value), and nothing if predicate returns false. constraints requires std :: predicate < Pred > declarations template < class T > class maybe { template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T > , maybe < T >> maybe < T >:: filter ( Pred && predicate ) ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto is_even = []( int n ) -> bool { return n % 2 == 0 ; }; assert ( maybe < int > {}. filter ( is_even ) == nothing ); assert ( maybe { just ( 3 )}. filter ( is_even ) == nothing ); assert ( maybe { just ( 4 )}. filter ( is_even ) == just ( 4 )); } // end example disj \u00b6 maybe<T> \u2192 maybe<T> \u2192 maybe<T> Returns the maybe if it contains a value, otherwise returns rhs. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated. declarations template < class T > class maybe { auto maybe < T >:: disj ( maybe < T > const & rhs ) -> maybe < T > ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); maybe < int > y = nothing ; assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 100 )); } { maybe x = just ( 2 ); maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe < int > y = nothing ; assert ( x . disj ( y ) == nothing ); } } // end example or_else \u00b6 maybe<T> \u2192 F \u2192 maybe<T> Returns the maybe if it contains a value, otherwise invokes f and returns the result. constraints requires { { f () } -> std :: convertible_to < maybe < T >> } declarations template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) & ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto nobody = []() -> maybe < std :: string > { return nothing ; }; auto vikings = []() -> maybe < std :: string > { return just ( \"vikings\" s ); }; assert ( maybe { just ( \"barbarians\" s )}. or_else ( vikings ) == just ( \"barbarians\" s )); assert ( maybe < std :: string > {}. or_else ( vikings ) == just ( \"vikings\" s )); assert ( maybe < std :: string > {}. or_else ( nobody ) == nothing ); } // end example get_or_emplace \u00b6 maybe<T> \u2192 Args... \u2192 T& Emplace constructs T into the maybe with expression std::forward<Args>(args)... if it is nothing , then returns a mutable reference to the contained value. constraints requires std :: constructible < T , Args && ... > declarations template < class T > class maybe { template < class ... Args > std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , T &> get_or_emplace ( Args && ... args ) & ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; struct noncopyable { noncopyable () = default ; noncopyable ( noncopyable const & ) = delete ; noncopyable & operator = ( noncopyable const & ) = delete ; noncopyable ( noncopyable && ) = default ; noncopyable & operator = ( noncopyable && ) = default ; bool operator == ( noncopyable && ) & { return true ; } bool operator == ( noncopyable && ) const & { return true ; } bool operator == ( noncopyable const & ) & { return true ; } bool operator == ( noncopyable const & ) const & { return true ; } }; int main () { maybe < noncopyable > x = nothing ; auto & y = x . get_or_emplace ( noncopyable {}); assert ( y == noncopyable {}); } // end example get_or_emplace_with \u00b6 maybe<T> \u2192 F \u2192 Args... \u2192 T& Emplace constructs T into the maybe with expression std::invoke(std::forward<F>(f), std::forward<Args>(args)...) if it is nothing , then returns a mutable reference to the contained value. constraints requires std :: invocable < F && , Args && ... > , && std :: constructible < T , std :: invoke_result_t < F && , Args && ... >>> , declarations template < class T > class maybe { template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , Args && ... > , std :: is_constructible < T , std :: invoke_result_t < F && , Args && ... >>> , T &> get_or_emplace_with ( F && f , Args && ... args ) & ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < int > x = nothing ; std :: ignore = x . get_or_emplace_with ([]{ return 5 ; }); std :: ignore = x . get_or_emplace_with ([]( auto x ){ return x ; }, 5 ); auto & y = x . get_or_emplace_with ( & std :: string :: size , \"12345\" s ); assert ( y == 5 ); y = 7 ; assert ( x == just ( 7 )); } // end example replace \u00b6 maybe<T> \u2192 Args... \u2192 maybe<T> Replaces the actual value in the maybe by expression std::forward<Args>(args)... , returning the old value if present, leaving a just value in its place without deinitializing either one. constraints requires std :: constructible < T , Args && ... > declarations template < class T > class maybe { maybe < T > replace ( Args && ... args ) & ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); auto old = x . replace ( 5 ); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace ( 3 ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example replace_with \u00b6 maybe<T> \u2192 F \u2192 Args... \u2192 maybe<T> Replaces the actual value in the maybe by expression std::invoke(std::forward<F>(f), std::forward<Args>(args)...) , returning the old value if present, leaving a just value in its place without deinitializing either one. constraints requires std :: invocable < F && , Args && ... > && std :: constructible < T , std :: invoke_result_t < F && , Args && ... >> declarations template < class T > class maybe { template < class F , class ... Args > maybe < T > replace_with ( F && f , Args && ... args ) & ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); auto old = x . replace_with ([]{ return 5 ; }); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace_with ( & std :: string :: size , \"foo\" s ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example cloned \u00b6 maybe<T&> \u2192 maybe<T> Maps a maybe<T&> to a maybe<T> by deep copying the contents of the maybe. constraints requires std :: copyable < T > declarations template < class T > class maybe { auto maybe < T &>:: cloned () & -> maybe < T > ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int x = 12 ; maybe < int &> opt_x = just ( x ); assert ( opt_x == just ( 12 )); assert ( & ( opt_x . unwrap ()) == & x ); auto shallow_copied = opt_x ; assert ( & ( shallow_copied . unwrap ()) == & x ); auto cloned = opt_x . cloned (); assert ( cloned == just ( 12 )); assert ( & ( cloned . unwrap ()) != & x ); } // end example unwrap_or_default \u00b6 maybe<T> \u2192 T Returns the contained value or a default. If just , returns the contained value, otherwise if nothing , returns the default value for that type. constraints template < class T > class maybe { auto maybe < T >:: unwrap_or_default () const & -> std :: remove_reference_t < T > ; }; Remarks This operator shall be defined as deleted unless is_default_constructible_v<T> is true. Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < std :: string > x = nothing ; assert ( x . unwrap_or_default () == \"\" s ); } // end example transpose \u00b6 maybe<basic_result<_, T, E>> \u2192 basic_result<_, maybe<T>, E> Transposes a maybe of a result into a result of a maybe . nothing will be mapped to success(nothing) . just(success(_)) and just(failure(_)) will be mapped to success(just(_)) and failure(_) \u3000(_ is a placeholder). declarations template < class T > class maybe { maybe < basic_result < _ , T , E >>:: transpose () const & -> basic_result < _ , maybe < T > , E > ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x == y . transpose ()); } // end example flatten \u00b6 maybe<maybe<T>> \u2192 maybe<T> Converts from maybe<maybe<T>> to maybe<T> . declarations template < class T > class maybe { auto maybe < maybe < T >>:: flatten () -> maybe < T > ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < maybe < int >> x = just ( just ( 6 )); assert ( just ( 6 ) == x . flatten ()); maybe < maybe < int >> y = just ( nothing ); assert ( nothing == y . flatten ()); maybe < maybe < int >> z = nothing ; assert ( nothing == z . flatten ()); // Flattening once only removes one level of nesting: maybe < maybe < maybe < int >>> nest = just ( just ( just ( 6 ))); assert ( just ( 6 ) == nest . flatten (). flatten ()); } // end example and_finally \u00b6 maybe<T> \u2192 void Invokes the provided function with following conditions: - if std::invocable<F, T> , the provided function with contained value, - else if std::invocable<F, T> , the provided function without contained value, - otherwise, doing nothing. declarations template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , value_type $ { CVREF } > , std :: is_invocable < F >>> and_finally ( F && f ) $ { CVREF } ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example or_finally \u00b6 maybe<T> \u2192 F \u2192 void Invokes the provided function (if nothing), or doing nothing (if any). constraints requires std :: invocable < F > declarations template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ); }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example and_peek \u00b6 maybe<T> \u2192 F \u2192 maybe<T> Peeks the contained value if self is just , then returns self. Invokes the provided function with the contained value and then returns self (if any), or returns self without doing anything (if not). constraints requires std :: invocable < F > declarations template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , value_type $ { CVREF } > , std :: is_invocable < F >> , maybe &> and_peek ( F && f ) $ { CVREF }; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example or_peek \u00b6 maybe<T> \u2192 F \u2192 maybe<T> Invokes the provided function and then returns self (if nothing), or returns self without doing anything (if any). declarations template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &> or_peek ( F && f ) $ { CVREF } ; }; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example range_to_maybe \u00b6 Note In header <mitama/maybe/range_to_maybe.hpp> . Range \u2192 maybe<typename Range::value_type> The range_to_maybe function returns nothing on an empty range or just(v) where v is the first element of the range . declarations template < class Range > auto range_to_maybe ( Range && range ) -> maybe < decltype ( * begin ( range )) > ; Examples \u00b6 // begin example #include <mitama/maybe/maybe.hpp> #include <mitama/maybe/range_to_maybe.hpp> #include <cassert> using namespace mitama ; int main () { std :: vector v { 1 , 2 , 3 }; maybe x = range_to_maybe ( v ); assert ( x == just ( 1 )); maybe y = range_to_maybe ( std :: vector < int > {}); assert ( y == nothing ); int a [] = { 1 }; maybe z = range_to_maybe ( a ); assert ( z == 1 ); } // end example","title":"API Reference"},{"location":"maybe/APIs/#api_reference","text":"","title":"API reference"},{"location":"maybe/APIs/#is_just","text":"maybe<T> \u2192 bool Returns true if the maybe has some value. declaration template < class T > class maybe { constexpr bool maybe < T >:: is_just () const noexcept ; };","title":"is_just"},{"location":"maybe/APIs/#examples","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( x . is_just () ); maybe < int > y = nothing ; assert ( not y . is_just () ); } // end example","title":"Examples"},{"location":"maybe/APIs/#is_nothing","text":"maybe<T> \u2192 bool Returns true if the maybe is a nothing value. declarations template < class T > class maybe { constexpr bool maybe < T >:: is_nothing () const noexcept ; };","title":"is_nothing"},{"location":"maybe/APIs/#examples_1","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < int > x = just ( 2 ); assert ( ! x . is_nothing () ); maybe < int > y = nothing ; assert ( y . is_nothing () ); } // end example","title":"Examples"},{"location":"maybe/APIs/#as_ref","text":"maybe<T>& \u2192 maybe<T&> Converts from maybe<T>& to maybe<T&> . declarations template < class T > class maybe { auto maybe < T >:: as_ref () & -> maybe < T &> ; auto maybe < T >:: as_ref () const & -> maybe < const T &> ; };","title":"as_ref"},{"location":"maybe/APIs/#examples_2","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> #include <iostream> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe text = just ( \"Hello, world!\" s ); // First, cast `maybe<T>` to `maybe<T&>` with `as_ref`, auto text_length = text . as_ref (). map ( & std :: string :: size ); std :: cout << \"still can print text: \" << text << \" \\n \" ; } // end example","title":"Examples"},{"location":"maybe/APIs/#expect","text":"maybe<T> \u2192 string_view \u2192 T Unwraps a maybe, yielding the content of a just . declarations template < class T > class maybe { auto maybe < T >:: expect ( std :: string_view msg ) $ { CVREF } -> T $ { CVREF } ; }; Exceptions Raise mitama::runtime_panic if the value is a nothing with a custom panic message provided by msg .","title":"expect"},{"location":"maybe/APIs/#examples_3","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"value\" s ); assert ( x . expect ( \"the world is ending\" ) == \"value\" s ); } try { maybe < int > x = nothing ; x . expect ( \"the world is ending\" ); // panics with `the world is ending` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'the world is ending' } } // end example","title":"Examples"},{"location":"maybe/APIs/#unwrap","text":"maybe<T> \u2192 T Unwraps a maybe, yielding the content of a just . declarations template < class T > class maybe { auto maybe < T >:: unwrap () $ { CVREF } -> value_type $ { CVREF } ; }; Exceptions Raise mitama::runtime_panic if a maybe has not just value.","title":"unwrap"},{"location":"maybe/APIs/#examples_4","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( \"air\" s ); assert ( x . unwrap () == \"air\" s ); } try { maybe < int > x = nothing ; x . unwrap (); // raise an exception } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; // runtime panicked at 'called `maybe::unwrap()` on a `nothing` value' } } // end example","title":"Examples"},{"location":"maybe/APIs/#unwrap_or","text":"maybe<T> \u2192 T \u2192 T Returns the contained value or a default. Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. declarations template < class T > class maybe { template < class U > std :: enable_if_t < meta :: has_type < std :: common_type < value_type $ { CVREF }, U &&>>:: value , std :: common_type_t < value_type $ { CVREF }, U &&>> maybe < T >:: unwrap_or ( U && def ) $ { CVREF } ; };","title":"unwrap_or"},{"location":"maybe/APIs/#examples_5","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { assert ( maybe { just ( \"car\" s )}. unwrap_or ( \"bike\" s ) == \"car\" s ); assert ( maybe < std :: string > { nothing }. unwrap_or ( \"bike\" s ) == \"bike\" s ); } // end example","title":"Examples"},{"location":"maybe/APIs/#unwrap_or_else","text":"maybe<T> \u2192 F \u2192 T Returns the contained value or computes it from a invocable object op: F . constraints requires ( F && f ) { { f () } -> std :: convertible_to < T > ; } declarations template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , meta :: has_type < std :: common_type < value_type $ { CVREF }, std :: invoke_result_t < F &&>>>> , std :: common_type_t < value_type $ { CVREF }, std :: invoke_result_t < F &&>>> maybe < T >:: unwrap_or_else ( F && f ) $ { CVREF } ; };","title":"unwrap_or_else"},{"location":"maybe/APIs/#examples_6","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int k = 10 ; assert ( maybe { just ( 4 )}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 4 ); assert ( maybe < int > {}. unwrap_or_else ([ k ]{ return 2 * k ; }) == 20 ); } // end example","title":"Examples"},{"location":"maybe/APIs/#map","text":"maybe<T> \u2192 F \u2192 Args... \u2192 maybe<U> Maps a maybe<T> to maybe<U> by applying a function to a contained value. constraints requires { maybe < std :: invoke_result_t < F && , T , Args && ... >> ; } declarations template < class T > class maybe { template < class F , class ... Args , std :: enable_if_t < std :: is_invocable_v < F && , T $ { CVREF }, Args && ... > , bool > = false > auto maybe < T >:: map ( F && f , Args && ...) $ { CVREF } -> maybe < std :: invoke_result_t < F && , T $ { CVREF }, Args && ... >> ; };","title":"map"},{"location":"maybe/APIs/#examples_7","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe maybe_some_string = just ( \"Hello, World!\" s ); // `maybe::map` takes self *by ref*, // *not* consuming `maybe_some_string` maybe maybe_some_len = maybe_some_string . map ( & std :: string :: size ); assert ( maybe_some_len == just ( 13u )); } // end example","title":"Examples"},{"location":"maybe/APIs/#map_or","text":"maybe<T> \u2192 U \u2192 F \u2192 Args... \u2192 U Applies a function to the contained value (if any), or returns the provided default (if not). declarations template < class T > class maybe { template < class U , class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , value_type $ { CVREF }, Args && ... > , meta :: has_type < std :: common_type < U && , std :: invoke_result_t < F && , value_type $ { CVREF } > >>> , std :: common_type_t < U && , std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... >>> map_or ( U && , F && , Args && ...) $ { CVREF }; };","title":"map_or"},{"location":"maybe/APIs/#examples_8","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . map_or ( 42 , & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or ( 42 , & std :: string :: size ) == 42 ); } // end example","title":"Examples"},{"location":"maybe/APIs/#map_or_else","text":"maybe<T> \u2192 D \u2192 F \u2192 Args... \u2192 U Applies a function to the contained value (if any), or computes a default (if not). constraints requires { maybe < std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , T , Args && ... > > >> ; } declarations template < class D , class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < D &&> , std :: is_invocable < F && , value_type $ { CVREF }, Args && ... > , meta :: has_type < std :: common_type < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... > >>> , std :: common_type_t < std :: invoke_result_t < D &&> , std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... > >> map_or_else ( D && , F && , Args && ...) $ { CVREF };","title":"map_or_else"},{"location":"maybe/APIs/#examples_9","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { int k = 21 ; maybe x = just ( \"foo\" s ); assert ( x . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 3 ); maybe < std :: string > y = nothing ; assert ( y . map_or_else ([ k ]{ return 2 * k ; }, & std :: string :: size ) == 42 ); } // end example","title":"Examples"},{"location":"maybe/APIs/#ok_or","text":"maybe<T> \u2192 E [default=std::monostate] \u2192 result<T, E> Transforms the maybe<T> into a result<T, E> , mapping just(v) to success(v) and nothing to failure(err) . Arguments passed to ok_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use ok_or_else, which is lazily evaluated. declarations template < class T > class maybe { template < class E = std :: monostate > auto maybe < T >:: ok_or ( E && err = {}) & -> result < T , std :: remove_reference_t < E >> ; };","title":"ok_or"},{"location":"maybe/APIs/#examples_10","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or ( 0 ) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or ( 0 ) == failure ( 0 )); assert ( y . ok_or () == failure <> ()); } // end example","title":"Examples"},{"location":"maybe/APIs/#ok_or_else","text":"maybe<T> \u2192 F \u2192 result<T, E> Transforms the maybe<T> into a result<T, E> , mapping just(v) to success(v) and nothing to failure(err()) . constraints requires { result < T , std :: invoke_result_t < F , Args ... >> } declarations template < class T > class maybe { template < class F > std :: enable_if_t < std :: is_invocable_v < F &&> , result < T , std :: invoke_result_t < F &&>>> maybe < T >:: ok_or_else ( F && err ) ; };","title":"ok_or_else"},{"location":"maybe/APIs/#examples_11","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe x = just ( \"foo\" s ); assert ( x . ok_or_else ([]{ return 0 ; }) == success ( \"foo\" s )); maybe < std :: string > y = nothing ; assert ( y . ok_or_else ([]{ return 0 ; }) == failure ( 0 )); } // end example","title":"Examples"},{"location":"maybe/APIs/#conj","text":"maybe<T> \u2192 maybe<U> \u2192 maybe<U> Returns nothing if the lhs is nothing , otherwise returns rhs . declarations template < class T > class maybe { template < class U > auto maybe < T >:: conj ( maybe < U > const & rhs ) -> maybe < U > ; };","title":"conj"},{"location":"maybe/APIs/#examples_12","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } { maybe < int > x = nothing ; maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == nothing ); } { maybe x = just ( 2 ); maybe y = just ( \"foo\" s ); assert ( x . conj ( y ) == just ( \"foo\" s )); } { maybe < int > x = nothing ; maybe < std :: string > y = nothing ; assert ( x . conj ( y ) == nothing ); } } // end example","title":"Examples"},{"location":"maybe/APIs/#and_then","text":"maybe<T> \u2192 F \u2192 maybe<U> Returns nothing if the option is nothing , otherwise invokes f with the wrapped value and returns the result. Some languages call this operation flatmap. constraints requires ( is_maybe_v < std :: invoke_result_t < F && , T , Args ... >> ) declarations template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , value_type $ { CVREF }, Args && ... > , is_maybe < std :: decay_t < std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... >>>> , std :: invoke_result_t < F && , value_type $ { CVREF }, Args && ... >> and_then ( F && f , Args && ... args ) $ { CVREF }","title":"and_then"},{"location":"maybe/APIs/#examples_13","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto sq = []( int x ) -> maybe < int > { return just ( x * x ); }; auto nope = [](...) -> maybe < int > { return nothing ; }; assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( sq ) == just ( 16 )); assert ( maybe { just ( 2 )}. and_then ( sq ). and_then ( nope ) == nothing ); assert ( maybe { just ( 2 )}. and_then ( nope ). and_then ( sq ) == nothing ); assert ( nope (). and_then ( sq ). and_then ( sq ) == nothing ); } // end example","title":"Examples"},{"location":"maybe/APIs/#filter","text":"maybe<T> \u2192 Pred \u2192 maybe<T> Returns nothing if the option is nothing , otherwise invokes predicate with the wrapped value and returns: just(t) if predicate returns true (where t is the wrapped value), and nothing if predicate returns false. constraints requires std :: predicate < Pred > declarations template < class T > class maybe { template < class Pred > std :: enable_if_t < std :: is_invocable_r_v < bool , Pred && , T > , maybe < T >> maybe < T >:: filter ( Pred && predicate ) ; };","title":"filter"},{"location":"maybe/APIs/#examples_14","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { auto is_even = []( int n ) -> bool { return n % 2 == 0 ; }; assert ( maybe < int > {}. filter ( is_even ) == nothing ); assert ( maybe { just ( 3 )}. filter ( is_even ) == nothing ); assert ( maybe { just ( 4 )}. filter ( is_even ) == just ( 4 )); } // end example","title":"Examples"},{"location":"maybe/APIs/#disj","text":"maybe<T> \u2192 maybe<T> \u2192 maybe<T> Returns the maybe if it contains a value, otherwise returns rhs. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else, which is lazily evaluated. declarations template < class T > class maybe { auto maybe < T >:: disj ( maybe < T > const & rhs ) -> maybe < T > ; };","title":"disj"},{"location":"maybe/APIs/#examples_15","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); maybe < int > y = nothing ; assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 100 )); } { maybe x = just ( 2 ); maybe y = just ( 100 ); assert ( x . disj ( y ) == just ( 2 )); } { maybe < int > x = nothing ; maybe < int > y = nothing ; assert ( x . disj ( y ) == nothing ); } } // end example","title":"Examples"},{"location":"maybe/APIs/#or_else","text":"maybe<T> \u2192 F \u2192 maybe<T> Returns the maybe if it contains a value, otherwise invokes f and returns the result. constraints requires { { f () } -> std :: convertible_to < maybe < T >> } declarations template < class T > class maybe { template < class F > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F &&> , is_maybe_with < std :: decay_t < std :: invoke_result_t < F &&>> , T >> , maybe < T >> maybe < T >:: or_else ( F && f ) & ; };","title":"or_else"},{"location":"maybe/APIs/#examples_16","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto nobody = []() -> maybe < std :: string > { return nothing ; }; auto vikings = []() -> maybe < std :: string > { return just ( \"vikings\" s ); }; assert ( maybe { just ( \"barbarians\" s )}. or_else ( vikings ) == just ( \"barbarians\" s )); assert ( maybe < std :: string > {}. or_else ( vikings ) == just ( \"vikings\" s )); assert ( maybe < std :: string > {}. or_else ( nobody ) == nothing ); } // end example","title":"Examples"},{"location":"maybe/APIs/#get_or_emplace","text":"maybe<T> \u2192 Args... \u2192 T& Emplace constructs T into the maybe with expression std::forward<Args>(args)... if it is nothing , then returns a mutable reference to the contained value. constraints requires std :: constructible < T , Args && ... > declarations template < class T > class maybe { template < class ... Args > std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , T &> get_or_emplace ( Args && ... args ) & ; };","title":"get_or_emplace"},{"location":"maybe/APIs/#examples_17","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; struct noncopyable { noncopyable () = default ; noncopyable ( noncopyable const & ) = delete ; noncopyable & operator = ( noncopyable const & ) = delete ; noncopyable ( noncopyable && ) = default ; noncopyable & operator = ( noncopyable && ) = default ; bool operator == ( noncopyable && ) & { return true ; } bool operator == ( noncopyable && ) const & { return true ; } bool operator == ( noncopyable const & ) & { return true ; } bool operator == ( noncopyable const & ) const & { return true ; } }; int main () { maybe < noncopyable > x = nothing ; auto & y = x . get_or_emplace ( noncopyable {}); assert ( y == noncopyable {}); } // end example","title":"Examples"},{"location":"maybe/APIs/#get_or_emplace_with","text":"maybe<T> \u2192 F \u2192 Args... \u2192 T& Emplace constructs T into the maybe with expression std::invoke(std::forward<F>(f), std::forward<Args>(args)...) if it is nothing , then returns a mutable reference to the contained value. constraints requires std :: invocable < F && , Args && ... > , && std :: constructible < T , std :: invoke_result_t < F && , Args && ... >>> , declarations template < class T > class maybe { template < class F , class ... Args > std :: enable_if_t < std :: conjunction_v < std :: is_invocable < F && , Args && ... > , std :: is_constructible < T , std :: invoke_result_t < F && , Args && ... >>> , T &> get_or_emplace_with ( F && f , Args && ... args ) & ; };","title":"get_or_emplace_with"},{"location":"maybe/APIs/#examples_18","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < int > x = nothing ; std :: ignore = x . get_or_emplace_with ([]{ return 5 ; }); std :: ignore = x . get_or_emplace_with ([]( auto x ){ return x ; }, 5 ); auto & y = x . get_or_emplace_with ( & std :: string :: size , \"12345\" s ); assert ( y == 5 ); y = 7 ; assert ( x == just ( 7 )); } // end example","title":"Examples"},{"location":"maybe/APIs/#replace","text":"maybe<T> \u2192 Args... \u2192 maybe<T> Replaces the actual value in the maybe by expression std::forward<Args>(args)... , returning the old value if present, leaving a just value in its place without deinitializing either one. constraints requires std :: constructible < T , Args && ... > declarations template < class T > class maybe { maybe < T > replace ( Args && ... args ) & ; };","title":"replace"},{"location":"maybe/APIs/#examples_19","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { { maybe x = just ( 2 ); auto old = x . replace ( 5 ); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace ( 3 ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example","title":"Examples"},{"location":"maybe/APIs/#replace_with","text":"maybe<T> \u2192 F \u2192 Args... \u2192 maybe<T> Replaces the actual value in the maybe by expression std::invoke(std::forward<F>(f), std::forward<Args>(args)...) , returning the old value if present, leaving a just value in its place without deinitializing either one. constraints requires std :: invocable < F && , Args && ... > && std :: constructible < T , std :: invoke_result_t < F && , Args && ... >> declarations template < class T > class maybe { template < class F , class ... Args > maybe < T > replace_with ( F && f , Args && ... args ) & ; };","title":"replace_with"},{"location":"maybe/APIs/#examples_20","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { maybe x = just ( 2 ); auto old = x . replace_with ([]{ return 5 ; }); assert ( x == just ( 5 )); assert ( old == just ( 2 )); } { maybe < int > x = nothing ; auto old = x . replace_with ( & std :: string :: size , \"foo\" s ); assert ( x == just ( 3 )); assert ( old == nothing ); } } // end example","title":"Examples"},{"location":"maybe/APIs/#cloned","text":"maybe<T&> \u2192 maybe<T> Maps a maybe<T&> to a maybe<T> by deep copying the contents of the maybe. constraints requires std :: copyable < T > declarations template < class T > class maybe { auto maybe < T &>:: cloned () & -> maybe < T > ; };","title":"cloned"},{"location":"maybe/APIs/#examples_21","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { int x = 12 ; maybe < int &> opt_x = just ( x ); assert ( opt_x == just ( 12 )); assert ( & ( opt_x . unwrap ()) == & x ); auto shallow_copied = opt_x ; assert ( & ( shallow_copied . unwrap ()) == & x ); auto cloned = opt_x . cloned (); assert ( cloned == just ( 12 )); assert ( & ( cloned . unwrap ()) != & x ); } // end example","title":"Examples"},{"location":"maybe/APIs/#unwrap_or_default","text":"maybe<T> \u2192 T Returns the contained value or a default. If just , returns the contained value, otherwise if nothing , returns the default value for that type. constraints template < class T > class maybe { auto maybe < T >:: unwrap_or_default () const & -> std :: remove_reference_t < T > ; }; Remarks This operator shall be defined as deleted unless is_default_constructible_v<T> is true.","title":"unwrap_or_default"},{"location":"maybe/APIs/#examples_22","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { maybe < std :: string > x = nothing ; assert ( x . unwrap_or_default () == \"\" s ); } // end example","title":"Examples"},{"location":"maybe/APIs/#transpose","text":"maybe<basic_result<_, T, E>> \u2192 basic_result<_, maybe<T>, E> Transposes a maybe of a result into a result of a maybe . nothing will be mapped to success(nothing) . just(success(_)) and just(failure(_)) will be mapped to success(just(_)) and failure(_) \u3000(_ is a placeholder). declarations template < class T > class maybe { maybe < basic_result < _ , T , E >>:: transpose () const & -> basic_result < _ , maybe < T > , E > ; };","title":"transpose"},{"location":"maybe/APIs/#examples_23","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x == y . transpose ()); } // end example","title":"Examples"},{"location":"maybe/APIs/#flatten","text":"maybe<maybe<T>> \u2192 maybe<T> Converts from maybe<maybe<T>> to maybe<T> . declarations template < class T > class maybe { auto maybe < maybe < T >>:: flatten () -> maybe < T > ; };","title":"flatten"},{"location":"maybe/APIs/#examples_24","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe < maybe < int >> x = just ( just ( 6 )); assert ( just ( 6 ) == x . flatten ()); maybe < maybe < int >> y = just ( nothing ); assert ( nothing == y . flatten ()); maybe < maybe < int >> z = nothing ; assert ( nothing == z . flatten ()); // Flattening once only removes one level of nesting: maybe < maybe < maybe < int >>> nest = just ( just ( just ( 6 ))); assert ( just ( 6 ) == nest . flatten (). flatten ()); } // end example","title":"Examples"},{"location":"maybe/APIs/#and_finally","text":"maybe<T> \u2192 void Invokes the provided function with following conditions: - if std::invocable<F, T> , the provided function with contained value, - else if std::invocable<F, T> , the provided function without contained value, - otherwise, doing nothing. declarations template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , value_type $ { CVREF } > , std :: is_invocable < F >>> and_finally ( F && f ) $ { CVREF } ; };","title":"and_finally"},{"location":"maybe/APIs/#examples_25","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":"Examples"},{"location":"maybe/APIs/#or_finally","text":"maybe<T> \u2192 F \u2192 void Invokes the provided function (if nothing), or doing nothing (if any). constraints requires std :: invocable < F > declarations template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F >> or_finally ( F && f ); };","title":"or_finally"},{"location":"maybe/APIs/#examples_26","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"Examples"},{"location":"maybe/APIs/#and_peek","text":"maybe<T> \u2192 F \u2192 maybe<T> Peeks the contained value if self is just , then returns self. Invokes the provided function with the contained value and then returns self (if any), or returns self without doing anything (if not). constraints requires std :: invocable < F > declarations template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , value_type $ { CVREF } > , std :: is_invocable < F >> , maybe &> and_peek ( F && f ) $ { CVREF }; };","title":"and_peek"},{"location":"maybe/APIs/#examples_27","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = just ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == just ( 42 )); assert ( hook == 42 ); } // end example","title":"Examples"},{"location":"maybe/APIs/#or_peek","text":"maybe<T> \u2192 F \u2192 maybe<T> Invokes the provided function and then returns self (if nothing), or returns self without doing anything (if any). declarations template < class T > class maybe { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F > , maybe &> or_peek ( F && f ) $ { CVREF } ; };","title":"or_peek"},{"location":"maybe/APIs/#examples_28","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & hook ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"Examples"},{"location":"maybe/APIs/#range_to_maybe","text":"Note In header <mitama/maybe/range_to_maybe.hpp> . Range \u2192 maybe<typename Range::value_type> The range_to_maybe function returns nothing on an empty range or just(v) where v is the first element of the range . declarations template < class Range > auto range_to_maybe ( Range && range ) -> maybe < decltype ( * begin ( range )) > ;","title":"range_to_maybe"},{"location":"maybe/APIs/#examples_29","text":"// begin example #include <mitama/maybe/maybe.hpp> #include <mitama/maybe/range_to_maybe.hpp> #include <cassert> using namespace mitama ; int main () { std :: vector v { 1 , 2 , 3 }; maybe x = range_to_maybe ( v ); assert ( x == just ( 1 )); maybe y = range_to_maybe ( std :: vector < int > {}); assert ( y == nothing ); int a [] = { 1 }; maybe z = range_to_maybe ( a ); assert ( z == 1 ); } // end example","title":"Examples"},{"location":"maybe/comparisons/","text":"operator==, !=, <, <=, >, >=(maybe) \u00b6 namespace mitama { // Compare two maybe objects template < class T , class U > constexpr bool operator == ( const maybe < T >& lhs , const maybe < U >& rhs ); // (1) template < class T , class U > constexpr bool operator != ( const maybe < T >& lhs , const maybe < U >& rhs ); // (2) template < class T , class U > constexpr bool operator < ( const maybe < T >& lhs , const maybe < U >& rhs ); // (3) template < class T , class U > constexpr bool operator <= ( const maybe < T >& lhs , const maybe < U >& rhs ); // (4) template < class T , class U > constexpr bool operator > ( const maybe < T >& lhs , const maybe < U >& rhs ); // (5) template < class T , class U > constexpr bool operator >= ( const maybe < T >& lhs , const maybe < U >& rhs ); // (6) // Compare a maybe object with a nothing template < class T > constexpr bool operator == ( const maybe < T >& opt , nothing_t ) noexcept ; // (7) template < class T > constexpr bool operator == ( nothing_t , const maybe < T >& opt ) noexcept ; // (8) template < class T > constexpr bool operator != ( const maybe < T >& opt , nothing_t ) noexcept ; // (9) template < class T > constexpr bool operator != ( nothing_t , const maybe < T >& opt ) noexcept ; // (10) template < class T > constexpr bool operator < ( const maybe < T >& opt , nothing_t ) noexcept ; // (11) template < class T > constexpr bool operator < ( nothing_t , const maybe < T >& opt ) noexcept ; // (12) template < class T > constexpr bool operator <= ( const maybe < T >& opt , nothing_t ) noexcept ; // (13) template < class T > constexpr bool operator <= ( nothing_t , const maybe < T >& opt ) noexcept ; // (14) template < class T > constexpr bool operator > ( const maybe < T >& opt , nothing_t ) noexcept ; // (15) template < class T > constexpr bool operator > ( nothing_t , const maybe < T >& opt ) noexcept ; // (16) template < class T > constexpr bool operator >= ( const maybe < T >& opt , nothing_t ) noexcept ; // (17) template < class T > constexpr bool operator >= ( nothing_t , const maybe < T >& opt ) noexcept ; // (18) // Compare a maybe object with a just(value) template < class T , class U > constexpr bool operator == ( const maybe < T >& opt , just_t < U > const & some ); // (19) template < class T , class U > constexpr bool operator == ( just_t < T > const & some , const maybe < U >& opt ); // (20) template < class T , class U > constexpr bool operator != ( const maybe < T >& opt , just_t < U > const & some ); // (21) template < class T , class U > constexpr bool operator != ( just_t < T > const & some , const maybe < U >& opt ); // (22) template < class T , class U > constexpr bool operator < ( const maybe < T >& opt , just_t < U > const & some ); // (23) template < class T , class U > constexpr bool operator < ( just_t < T > const & some , const maybe < U >& opt ); // (24) template < class T , class U > constexpr bool operator <= ( const maybe < T >& opt , just_t < U > const & some ); // (25) template < class T , class U > constexpr bool operator <= ( just_t < T > const & some , const maybe < U >& opt ); // (26) template < class T , class U > constexpr bool operator > ( const maybe < T >& opt , just_t < U > const & some ); // (27) template < class T , class U > constexpr bool operator > ( just_t < T > const & some , const maybe < U >& opt ); // (28) template < class T , class U > constexpr bool operator >= ( const maybe < T >& opt , just_t < U > const & some ); // (29) template < class T , class U > constexpr bool operator >= ( just_t < T > const & some , const maybe < U >& opt ); // (30) // Compare a maybe object with a T template < class T , class U > constexpr bool operator == ( const maybe < T >& opt , const U & value ); // (31) template < class T , class U > constexpr bool operator == ( const T & value , const maybe < U >& opt ); // (32) template < class T , class U > constexpr bool operator != ( const maybe < T >& opt , const U & value ); // (33) template < class T , class U > constexpr bool operator != ( const T & value , const maybe < U >& opt ); // (34) template < class T , class U > constexpr bool operator < ( const maybe < T >& opt , const U & value ); // (35) template < class T , class U > constexpr bool operator < ( const T & value , const maybe < U >& opt ); // (36) template < class T , class U > constexpr bool operator <= ( const maybe < T >& opt , const U & value ); // (37) template < class T , class U > constexpr bool operator <= ( const T & value , const maybe < U >& opt ); // (38) template < class T , class U > constexpr bool operator > ( const maybe < T >& opt , const U & value ); // (39) template < class T , class U > constexpr bool operator > ( const T & value , const maybe < U >& opt ); // (40) template < class T , class U > constexpr bool operator >= ( const maybe < T >& opt , const U & value ); // (41) template < class T , class U > constexpr bool operator >= ( const T & value , const maybe < U >& opt ); // (42) } Performs comparison operations on maybe objects. 1-6) Compares two maybe objects, lhs and rhs . The contained values are compared (using the corresponding operator of T and U ) only if both lhs and rhs contain values. Otherwise, lhs is considered equal to rhs if, and only if, both lhs and rhs do not contain a value. lhs is considered less than rhs if, and only if, rhs contains a value and lhs does not. 7-18) Compares opt with a nothing . Equivalent to (1-6) when comparing to a maybe that does not contain a value. 19-30) Compares opt with a some := just_t(value) . The values are compared (using the corresponding operator of T ) only if opt contains a value. Otherwise, opt is considered less than some . If the corresponding comparison expression between opt.unwrap() and value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 31-42) Compares opt with a value . Equivalent to (19-30) expression opt ~ just(value) . Parameters lhs , rhs , opt - a maybe object to compare some - a just_t object to compare value - value to compare to the contained value Return value If bool(lhs) != bool(rhs) , returns false Otherwise, if bool(lhs) == false (and so bool(rhs) == false as well), returns true Otherwise, returns lhs.unwrap() == rhs.unwrap() . If bool(lhs) != bool(rhs) , returns true Otherwise, if bool(lhs) == false (and so bool(rhs) == false as well), returns false Otherwise, returns lhs.unwrap() != rhs.unwrap() . If bool(rhs) == false returns false Otherwise, if bool(lhs) == false , returns true Otherwise returns lhs.unwrap() < rhs.unwrap() . If bool(lhs) == false returns true Otherwise, if bool(rhs) == false , returns false Otherwise returns lhs.unwrap() <= rhs.unwrap() . If bool(lhs) == false returns false Otherwise, if bool(rhs) == false , returns true Otherwise returns lhs.unwrap() > rhs.unwrap() . If bool(rhs) == false returns true Otherwise, if bool(lhs) == false , returns false Otherwise returns lhs.unwrap() >= rhs.unwrap() . Returns opt.is_nothing() . Returns opt.is_nothing() . Returns opt.is_just() . Returns opt.is_just() . Returns false . Returns opt.is_just() . Returns opt.is_nothing() . Returns true . Returns opt.is_just() . Returns false . Returns true . Returns opt.is_nothing() . Returns opt.is_just() ? opt.unwrap() == some.value : false . Returns opt.is_just() ? some.value == opt.unwrap() : false . Returns opt.is_just() ? opt.unwrap() != some.value : true . Returns opt.is_just() ? some.value != opt.unwrap() : true . Returns opt.is_just() ? opt.unwrap() < some.value : true . Returns opt.is_just() ? some.value < opt.unwrap() : false . Returns opt.is_just() ? opt.unwrap() <= some.value : true . Returns opt.is_just() ? some.value <= opt.unwrap() : false . Returns opt.is_just() ? opt.unwrap() > some.value : false . Returns opt.is_just() ? some.value > opt.unwrap() : true . Returns opt.is_just() ? opt.unwrap() >= some.value : false . Returns opt.is_just() ? some.value >= opt.unwrap() : true . Returns opt == just(value) . Returns just(value) == opt . Returns opt != just(value) . Returns just(value) != opt . Returns opt < just(value) . Returns just(value) < opt . Returns opt <= just(value) . Returns just(value) <= opt . Returns opt > just(value) . Returns just(value) > opt . Returns opt >= just(value) . Returns just(value) >= opt . Note some.value : value is a private member of just_t (actually, cannot access to it).","title":"Comparisons"},{"location":"maybe/comparisons/#operator_maybe","text":"namespace mitama { // Compare two maybe objects template < class T , class U > constexpr bool operator == ( const maybe < T >& lhs , const maybe < U >& rhs ); // (1) template < class T , class U > constexpr bool operator != ( const maybe < T >& lhs , const maybe < U >& rhs ); // (2) template < class T , class U > constexpr bool operator < ( const maybe < T >& lhs , const maybe < U >& rhs ); // (3) template < class T , class U > constexpr bool operator <= ( const maybe < T >& lhs , const maybe < U >& rhs ); // (4) template < class T , class U > constexpr bool operator > ( const maybe < T >& lhs , const maybe < U >& rhs ); // (5) template < class T , class U > constexpr bool operator >= ( const maybe < T >& lhs , const maybe < U >& rhs ); // (6) // Compare a maybe object with a nothing template < class T > constexpr bool operator == ( const maybe < T >& opt , nothing_t ) noexcept ; // (7) template < class T > constexpr bool operator == ( nothing_t , const maybe < T >& opt ) noexcept ; // (8) template < class T > constexpr bool operator != ( const maybe < T >& opt , nothing_t ) noexcept ; // (9) template < class T > constexpr bool operator != ( nothing_t , const maybe < T >& opt ) noexcept ; // (10) template < class T > constexpr bool operator < ( const maybe < T >& opt , nothing_t ) noexcept ; // (11) template < class T > constexpr bool operator < ( nothing_t , const maybe < T >& opt ) noexcept ; // (12) template < class T > constexpr bool operator <= ( const maybe < T >& opt , nothing_t ) noexcept ; // (13) template < class T > constexpr bool operator <= ( nothing_t , const maybe < T >& opt ) noexcept ; // (14) template < class T > constexpr bool operator > ( const maybe < T >& opt , nothing_t ) noexcept ; // (15) template < class T > constexpr bool operator > ( nothing_t , const maybe < T >& opt ) noexcept ; // (16) template < class T > constexpr bool operator >= ( const maybe < T >& opt , nothing_t ) noexcept ; // (17) template < class T > constexpr bool operator >= ( nothing_t , const maybe < T >& opt ) noexcept ; // (18) // Compare a maybe object with a just(value) template < class T , class U > constexpr bool operator == ( const maybe < T >& opt , just_t < U > const & some ); // (19) template < class T , class U > constexpr bool operator == ( just_t < T > const & some , const maybe < U >& opt ); // (20) template < class T , class U > constexpr bool operator != ( const maybe < T >& opt , just_t < U > const & some ); // (21) template < class T , class U > constexpr bool operator != ( just_t < T > const & some , const maybe < U >& opt ); // (22) template < class T , class U > constexpr bool operator < ( const maybe < T >& opt , just_t < U > const & some ); // (23) template < class T , class U > constexpr bool operator < ( just_t < T > const & some , const maybe < U >& opt ); // (24) template < class T , class U > constexpr bool operator <= ( const maybe < T >& opt , just_t < U > const & some ); // (25) template < class T , class U > constexpr bool operator <= ( just_t < T > const & some , const maybe < U >& opt ); // (26) template < class T , class U > constexpr bool operator > ( const maybe < T >& opt , just_t < U > const & some ); // (27) template < class T , class U > constexpr bool operator > ( just_t < T > const & some , const maybe < U >& opt ); // (28) template < class T , class U > constexpr bool operator >= ( const maybe < T >& opt , just_t < U > const & some ); // (29) template < class T , class U > constexpr bool operator >= ( just_t < T > const & some , const maybe < U >& opt ); // (30) // Compare a maybe object with a T template < class T , class U > constexpr bool operator == ( const maybe < T >& opt , const U & value ); // (31) template < class T , class U > constexpr bool operator == ( const T & value , const maybe < U >& opt ); // (32) template < class T , class U > constexpr bool operator != ( const maybe < T >& opt , const U & value ); // (33) template < class T , class U > constexpr bool operator != ( const T & value , const maybe < U >& opt ); // (34) template < class T , class U > constexpr bool operator < ( const maybe < T >& opt , const U & value ); // (35) template < class T , class U > constexpr bool operator < ( const T & value , const maybe < U >& opt ); // (36) template < class T , class U > constexpr bool operator <= ( const maybe < T >& opt , const U & value ); // (37) template < class T , class U > constexpr bool operator <= ( const T & value , const maybe < U >& opt ); // (38) template < class T , class U > constexpr bool operator > ( const maybe < T >& opt , const U & value ); // (39) template < class T , class U > constexpr bool operator > ( const T & value , const maybe < U >& opt ); // (40) template < class T , class U > constexpr bool operator >= ( const maybe < T >& opt , const U & value ); // (41) template < class T , class U > constexpr bool operator >= ( const T & value , const maybe < U >& opt ); // (42) } Performs comparison operations on maybe objects. 1-6) Compares two maybe objects, lhs and rhs . The contained values are compared (using the corresponding operator of T and U ) only if both lhs and rhs contain values. Otherwise, lhs is considered equal to rhs if, and only if, both lhs and rhs do not contain a value. lhs is considered less than rhs if, and only if, rhs contains a value and lhs does not. 7-18) Compares opt with a nothing . Equivalent to (1-6) when comparing to a maybe that does not contain a value. 19-30) Compares opt with a some := just_t(value) . The values are compared (using the corresponding operator of T ) only if opt contains a value. Otherwise, opt is considered less than some . If the corresponding comparison expression between opt.unwrap() and value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 31-42) Compares opt with a value . Equivalent to (19-30) expression opt ~ just(value) . Parameters lhs , rhs , opt - a maybe object to compare some - a just_t object to compare value - value to compare to the contained value Return value If bool(lhs) != bool(rhs) , returns false Otherwise, if bool(lhs) == false (and so bool(rhs) == false as well), returns true Otherwise, returns lhs.unwrap() == rhs.unwrap() . If bool(lhs) != bool(rhs) , returns true Otherwise, if bool(lhs) == false (and so bool(rhs) == false as well), returns false Otherwise, returns lhs.unwrap() != rhs.unwrap() . If bool(rhs) == false returns false Otherwise, if bool(lhs) == false , returns true Otherwise returns lhs.unwrap() < rhs.unwrap() . If bool(lhs) == false returns true Otherwise, if bool(rhs) == false , returns false Otherwise returns lhs.unwrap() <= rhs.unwrap() . If bool(lhs) == false returns false Otherwise, if bool(rhs) == false , returns true Otherwise returns lhs.unwrap() > rhs.unwrap() . If bool(rhs) == false returns true Otherwise, if bool(lhs) == false , returns false Otherwise returns lhs.unwrap() >= rhs.unwrap() . Returns opt.is_nothing() . Returns opt.is_nothing() . Returns opt.is_just() . Returns opt.is_just() . Returns false . Returns opt.is_just() . Returns opt.is_nothing() . Returns true . Returns opt.is_just() . Returns false . Returns true . Returns opt.is_nothing() . Returns opt.is_just() ? opt.unwrap() == some.value : false . Returns opt.is_just() ? some.value == opt.unwrap() : false . Returns opt.is_just() ? opt.unwrap() != some.value : true . Returns opt.is_just() ? some.value != opt.unwrap() : true . Returns opt.is_just() ? opt.unwrap() < some.value : true . Returns opt.is_just() ? some.value < opt.unwrap() : false . Returns opt.is_just() ? opt.unwrap() <= some.value : true . Returns opt.is_just() ? some.value <= opt.unwrap() : false . Returns opt.is_just() ? opt.unwrap() > some.value : false . Returns opt.is_just() ? some.value > opt.unwrap() : true . Returns opt.is_just() ? opt.unwrap() >= some.value : false . Returns opt.is_just() ? some.value >= opt.unwrap() : true . Returns opt == just(value) . Returns just(value) == opt . Returns opt != just(value) . Returns just(value) != opt . Returns opt < just(value) . Returns just(value) < opt . Returns opt <= just(value) . Returns just(value) <= opt . Returns opt > just(value) . Returns just(value) > opt . Returns opt >= just(value) . Returns just(value) >= opt . Note some.value : value is a private member of just_t (actually, cannot access to it).","title":"operator==, !=, &lt;, &lt;=, &gt;, &gt;=(maybe)"},{"location":"maybe/intro/","text":"Introduction \u00b6 Definition of class maybe \u00b6 namespace mitama { template < class T , class = void // for detection idiom > class maybe ; } Concepts \u00b6 T must satisfy the following requirements: Complete type (if T is not reference type) or Reference Type (possibly incomplete type) Destructible just/nothing \u00b6 just and nothing are in-place factory for maybe<T> . If you want to initialize maybe<T> with some value, initialize with just(value) . mitama :: maybe < int > some_int = mitama :: just ( 42 ); Similarly, if you want to initialize maybe<T> with none value, initialize with nothing . mitama :: maybe < int > nope_int = mitama :: nothing ;","title":"Maybe 101"},{"location":"maybe/intro/#introduction","text":"","title":"Introduction"},{"location":"maybe/intro/#definition_of_class_maybe","text":"namespace mitama { template < class T , class = void // for detection idiom > class maybe ; }","title":"Definition of class maybe"},{"location":"maybe/intro/#concepts","text":"T must satisfy the following requirements: Complete type (if T is not reference type) or Reference Type (possibly incomplete type) Destructible","title":"Concepts"},{"location":"maybe/intro/#justnothing","text":"just and nothing are in-place factory for maybe<T> . If you want to initialize maybe<T> with some value, initialize with just(value) . mitama :: maybe < int > some_int = mitama :: just ( 42 ); Similarly, if you want to initialize maybe<T> with none value, initialize with nothing . mitama :: maybe < int > nope_int = mitama :: nothing ;","title":"just/nothing"},{"location":"maybe/metafunctions/","text":"Meta functions \u00b6 is_just \u00b6 template < class > struct is_just : std :: false_type {}; template < class T > struct is_just < just_t < T >> : std :: true_type {}; template < class T > inline constexpr bool is_just_v = is_just < T >:: value ; is_nothing \u00b6 template < class > struct is_nothing : std :: false_type {}; template < class T > struct is_nothing < nothing_t < T >> : std :: true_type {}; template < class T > inline constexpr bool is_nothing_v = is_nothing < T >:: value ; is_maybe \u00b6 template < class > struct is_maybe : std :: false_type {}; template < class T > struct is_maybe < maybe < T >> : std :: true_type {}; template < class T > inline constexpr bool is_maybe_v = is_maybe < T >:: value ;","title":"Meta Functions"},{"location":"maybe/metafunctions/#meta_functions","text":"","title":"Meta functions"},{"location":"maybe/metafunctions/#is_just","text":"template < class > struct is_just : std :: false_type {}; template < class T > struct is_just < just_t < T >> : std :: true_type {}; template < class T > inline constexpr bool is_just_v = is_just < T >:: value ;","title":"is_just"},{"location":"maybe/metafunctions/#is_nothing","text":"template < class > struct is_nothing : std :: false_type {}; template < class T > struct is_nothing < nothing_t < T >> : std :: true_type {}; template < class T > inline constexpr bool is_nothing_v = is_nothing < T >:: value ;","title":"is_nothing"},{"location":"maybe/metafunctions/#is_maybe","text":"template < class > struct is_maybe : std :: false_type {}; template < class T > struct is_maybe < maybe < T >> : std :: true_type {}; template < class T > inline constexpr bool is_maybe_v = is_maybe < T >:: value ;","title":"is_maybe"},{"location":"maybe/special_members/","text":"Constructors \u00b6 default constructor [1/7] \u00b6 maybe () = default ; copy constructor [2/7] \u00b6 maybe ( maybe const & ) = default ; constructor [3/7] \u00b6 maybe ( maybe && ) = default ; constructor for nothing [4/7] \u00b6 Delegates to default constructor. maybe ( const nothing_t ) : maybe () {} constructor for maybe<U>, where constructible T from U [5/7] \u00b6 template < typename U , std :: enable_if_t < std :: disjunction_v < mitamagic :: is_pointer_like < std :: remove_reference_t < U >> , std :: is_pointer < std :: remove_reference_t < U >>> , bool > = false > maybe ( U && u ) : storage_ () { if ( u ) storage_ . emplace ( * std :: forward < U > ( u )); } in-place constructor [6/7] \u00b6 template < class ... Args , std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , Args && ... args ) : storage_ ( etude :: in_place ( std :: forward < Args > ( args )...)) {} in-place constructor with initializer_list [7/7] \u00b6 template < class U , class ... Args , std :: enable_if_t < std :: is_constructible_v < T , std :: initializer_list < U > , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , std :: initializer_list < U > il , Args && ... args ) : storage_ ( etude :: in_place ( il , std :: forward < Args > ( args )...)) {} Assignment operators \u00b6 copy assignment [\u00bd] \u00b6 maybe & operator = ( maybe const & ) = default ; move assignment [\u00bd] \u00b6 maybe & operator = ( maybe && ) = default ;","title":"Special Members"},{"location":"maybe/special_members/#constructors","text":"","title":"Constructors"},{"location":"maybe/special_members/#default_constructor_17","text":"maybe () = default ;","title":"default constructor [1/7]"},{"location":"maybe/special_members/#copy_constructor_27","text":"maybe ( maybe const & ) = default ;","title":"copy constructor [2/7]"},{"location":"maybe/special_members/#constructor_37","text":"maybe ( maybe && ) = default ;","title":"constructor [3/7]"},{"location":"maybe/special_members/#constructor_for_nothing_47","text":"Delegates to default constructor. maybe ( const nothing_t ) : maybe () {}","title":"constructor for nothing [4/7]"},{"location":"maybe/special_members/#constructor_for_maybeu_where_constructible_t_from_u_57","text":"template < typename U , std :: enable_if_t < std :: disjunction_v < mitamagic :: is_pointer_like < std :: remove_reference_t < U >> , std :: is_pointer < std :: remove_reference_t < U >>> , bool > = false > maybe ( U && u ) : storage_ () { if ( u ) storage_ . emplace ( * std :: forward < U > ( u )); }","title":"constructor for maybe&lt;U&gt;, where constructible T from U  [5/7]"},{"location":"maybe/special_members/#in-place_constructor_67","text":"template < class ... Args , std :: enable_if_t < std :: is_constructible_v < T , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , Args && ... args ) : storage_ ( etude :: in_place ( std :: forward < Args > ( args )...)) {}","title":"in-place constructor [6/7]"},{"location":"maybe/special_members/#in-place_constructor_with_initializer_list_77","text":"template < class U , class ... Args , std :: enable_if_t < std :: is_constructible_v < T , std :: initializer_list < U > , Args && ... > , bool > = false > explicit maybe ( std :: in_place_t , std :: initializer_list < U > il , Args && ... args ) : storage_ ( etude :: in_place ( il , std :: forward < Args > ( args )...)) {}","title":"in-place constructor with initializer_list [7/7]"},{"location":"maybe/special_members/#assignment_operators","text":"","title":"Assignment operators"},{"location":"maybe/special_members/#copy_assignment_12","text":"maybe & operator = ( maybe const & ) = default ;","title":"copy assignment [1/2]"},{"location":"maybe/special_members/#move_assignment_12","text":"maybe & operator = ( maybe && ) = default ;","title":"move assignment [1/2]"},{"location":"release_notes/v1_0_0/","text":"Mitama.Result version 1.0.0 \u00b6 New features \u00b6 Result Modules basic_result class basic monadic member functions Ok/Err factory classes","title":"version 1.0.0"},{"location":"release_notes/v1_0_0/#mitamaresult_version_100","text":"","title":"Mitama.Result version 1.0.0"},{"location":"release_notes/v1_0_0/#new_features","text":"Result Modules basic_result class basic monadic member functions Ok/Err factory classes","title":"New features"},{"location":"release_notes/v1_0_1/","text":"Mitama.Result version 1.0.1 \u00b6 Enhancements \u00b6 Add pretty IO for the result class","title":"version 1.0.1"},{"location":"release_notes/v1_0_1/#mitamaresult_version_101","text":"","title":"Mitama.Result version 1.0.1"},{"location":"release_notes/v1_0_1/#enhancements","text":"Add pretty IO for the result class","title":"Enhancements"},{"location":"release_notes/v1_1_0/","text":"Mitama.Result version 1.1.0 \u00b6 New features \u00b6 Add unwrap_or_default","title":"version 1.1.0"},{"location":"release_notes/v1_1_0/#mitamaresult_version_110","text":"","title":"Mitama.Result version 1.1.0"},{"location":"release_notes/v1_1_0/#new_features","text":"Add unwrap_or_default","title":"New features"},{"location":"release_notes/v1_1_1/","text":"Mitama.Result version 1.1.1 \u00b6 Enhancements \u00b6 unwrap_or_default is now explicitly deleted if and only if std::is_default_constructible_v<T> || std::is_aggregate_v<T> is false. unwrap_or_else(O op) is now invokes op without a error value if and only if std::is_invocable_v<O, E> is false and std::is_invocable_v<O> is true.","title":"version 1.1.1"},{"location":"release_notes/v1_1_1/#mitamaresult_version_111","text":"","title":"Mitama.Result version 1.1.1"},{"location":"release_notes/v1_1_1/#enhancements","text":"unwrap_or_default is now explicitly deleted if and only if std::is_default_constructible_v<T> || std::is_aggregate_v<T> is false. unwrap_or_else(O op) is now invokes op without a error value if and only if std::is_invocable_v<O, E> is false and std::is_invocable_v<O> is true.","title":"Enhancements"},{"location":"release_notes/v1_1_2/","text":"Mitama.Result version 1.1.2 \u00b6 Bug fixes \u00b6 Result<T, E>::and_then(O&& op) do not participate in overload resolution if unless op returns Result<U, E> . std::invoke_result_t<O&&, T> must be returns Result<U, E> . It means op must only maps T -> U , never changes E . Result<T, E>::or_else(O&& op) do not participate in overload resolution if unless op returns Result<T, F> . std::invoke_result_t<O&&, E> must be returns Result<T, F> . It means op must only maps E -> F , never changes T .","title":"version 1.1.2"},{"location":"release_notes/v1_1_2/#mitamaresult_version_112","text":"","title":"Mitama.Result version 1.1.2"},{"location":"release_notes/v1_1_2/#bug_fixes","text":"Result<T, E>::and_then(O&& op) do not participate in overload resolution if unless op returns Result<U, E> . std::invoke_result_t<O&&, T> must be returns Result<U, E> . It means op must only maps T -> U , never changes E . Result<T, E>::or_else(O&& op) do not participate in overload resolution if unless op returns Result<T, F> . std::invoke_result_t<O&&, E> must be returns Result<T, F> . It means op must only maps E -> F , never changes T .","title":"Bug fixes"},{"location":"release_notes/v1_2_0/","text":"Mitama.Result version 1.2.0 \u00b6 New features \u00b6 Add transpose Add operator bool Add operator! for result Enhancements \u00b6 Ok<> / Err<> is now default constructible","title":"version 1.2.0"},{"location":"release_notes/v1_2_0/#mitamaresult_version_120","text":"","title":"Mitama.Result version 1.2.0"},{"location":"release_notes/v1_2_0/#new_features","text":"Add transpose Add operator bool Add operator! for result","title":"New features"},{"location":"release_notes/v1_2_0/#enhancements","text":"Ok<> / Err<> is now default constructible","title":"Enhancements"},{"location":"release_notes/v2_0_1/","text":"Mitama.Result version 2.0.1 \u00b6 New features \u00b6 Add map_or_else Ends to support \u00b6 gcc 7.x Start to support \u00b6 gcc 9.1 clang 8.0.0 clang 7.1.0","title":"version 2.0.1"},{"location":"release_notes/v2_0_1/#mitamaresult_version_201","text":"","title":"Mitama.Result version 2.0.1"},{"location":"release_notes/v2_0_1/#new_features","text":"Add map_or_else","title":"New features"},{"location":"release_notes/v2_0_1/#ends_to_support","text":"gcc 7.x","title":"Ends to support"},{"location":"release_notes/v2_0_1/#start_to_support","text":"gcc 9.1 clang 8.0.0 clang 7.1.0","title":"Start to support"},{"location":"release_notes/v2_1_0/","text":"Mitama.Result version 2.1.0 \u00b6 Bug fixes \u00b6 Fix compile errors in unwrap and unwrap_err","title":"version 2.1.0"},{"location":"release_notes/v2_1_0/#mitamaresult_version_210","text":"","title":"Mitama.Result version 2.1.0"},{"location":"release_notes/v2_1_0/#bug_fixes","text":"Fix compile errors in unwrap and unwrap_err","title":"Bug fixes"},{"location":"release_notes/v2_1_1/","text":"Mitama.Result version 2.1.1 \u00b6 Enhancements \u00b6 Mark the following functions as constexpr: default constructor for Ok/Err ok/err unwrap_or_else operator==","title":"version 2.1.1"},{"location":"release_notes/v2_1_1/#mitamaresult_version_211","text":"","title":"Mitama.Result version 2.1.1"},{"location":"release_notes/v2_1_1/#enhancements","text":"Mark the following functions as constexpr: default constructor for Ok/Err ok/err unwrap_or_else operator==","title":"Enhancements"},{"location":"release_notes/v3_0_0/","text":"Mitama.Result version 3.0.0 \u00b6 Enhancements \u00b6 change directory/namespace structure","title":"version 3.0.0"},{"location":"release_notes/v3_0_0/#mitamaresult_version_300","text":"","title":"Mitama.Result version 3.0.0"},{"location":"release_notes/v3_0_0/#enhancements","text":"change directory/namespace structure","title":"Enhancements"},{"location":"release_notes/v4_0_0/","text":"Mitama.Result version 4.0.0 \u00b6 New features \u00b6 match expression","title":"version 4.0.0"},{"location":"release_notes/v4_0_0/#mitamaresult_version_400","text":"","title":"Mitama.Result version 4.0.0"},{"location":"release_notes/v4_0_0/#new_features","text":"match expression","title":"New features"},{"location":"release_notes/v4_0_1/","text":"Mitama.Result version 4.0.1 \u00b6 bug fix \u00b6 fix compile error on valid code in match expression","title":"version 4.0.1"},{"location":"release_notes/v4_0_1/#mitamaresult_version_401","text":"","title":"Mitama.Result version 4.0.1"},{"location":"release_notes/v4_0_1/#bug_fix","text":"fix compile error on valid code in match expression","title":"bug fix"},{"location":"release_notes/v4_0_2/","text":"Mitama.Result version 4.0.2 \u00b6 bug fix \u00b6 mark operator bool explicit","title":"version 4.0.2"},{"location":"release_notes/v4_0_2/#mitamaresult_version_402","text":"","title":"Mitama.Result version 4.0.2"},{"location":"release_notes/v4_0_2/#bug_fix","text":"mark operator bool explicit","title":"bug fix"},{"location":"release_notes/v4_1_0/","text":"Mitama.Result version 4.1.0 \u00b6 New features \u00b6 expect expect_err match<R>","title":"version 4.1.0"},{"location":"release_notes/v4_1_0/#mitamaresult_version_410","text":"","title":"Mitama.Result version 4.1.0"},{"location":"release_notes/v4_1_0/#new_features","text":"expect expect_err match<R>","title":"New features"},{"location":"release_notes/v5_0_0/","text":"Mitama.Result version 5.0.0 \u00b6 Enhancements \u00b6 rename old new Result basic_result Ok success Err failure Improve formatting output New features \u00b6 in-place constructor for basic_result immutability ( result and mut_result ) basic_result support reference type new APIs as_ref as_mut indirect dangling","title":"version 5.0.0"},{"location":"release_notes/v5_0_0/#mitamaresult_version_500","text":"","title":"Mitama.Result version 5.0.0"},{"location":"release_notes/v5_0_0/#enhancements","text":"rename old new Result basic_result Ok success Err failure Improve formatting output","title":"Enhancements"},{"location":"release_notes/v5_0_0/#new_features","text":"in-place constructor for basic_result immutability ( result and mut_result ) basic_result support reference type new APIs as_ref as_mut indirect dangling","title":"New features"},{"location":"release_notes/v5_0_1/","text":"Mitama.Result version 5.0.1 \u00b6 Bug fixes \u00b6 Fix a compile error in operator<<","title":"version 5.0.1"},{"location":"release_notes/v5_0_1/#mitamaresult_version_501","text":"","title":"Mitama.Result version 5.0.1"},{"location":"release_notes/v5_0_1/#bug_fixes","text":"Fix a compile error in operator<<","title":"Bug fixes"},{"location":"release_notes/v5_0_2/","text":"Mitama.Result version 5.0.2 \u00b6 Bug fixes \u00b6 Fix a compile error in err() const& , unwrap , and unwrap_err","title":"version 5.0.2"},{"location":"release_notes/v5_0_2/#mitamaresult_version_502","text":"","title":"Mitama.Result version 5.0.2"},{"location":"release_notes/v5_0_2/#bug_fixes","text":"Fix a compile error in err() const& , unwrap , and unwrap_err","title":"Bug fixes"},{"location":"release_notes/v5_0_3/","text":"Mitama.Result version 5.0.3 \u00b6 Bug fixes \u00b6 Fix a compile error in unwrap and unwrap_err","title":"version 5.0.3"},{"location":"release_notes/v5_0_3/#mitamaresult_version_503","text":"","title":"Mitama.Result version 5.0.3"},{"location":"release_notes/v5_0_3/#bug_fixes","text":"Fix a compile error in unwrap and unwrap_err","title":"Bug fixes"},{"location":"release_notes/v6_0_0/","text":"Mitama.Result version 6.0.0 \u00b6 New features \u00b6 Add maybe , just , and nothing","title":"version 6.0.0"},{"location":"release_notes/v6_0_0/#mitamaresult_version_600","text":"","title":"Mitama.Result version 6.0.0"},{"location":"release_notes/v6_0_0/#new_features","text":"Add maybe , just , and nothing","title":"New features"},{"location":"release_notes/v6_1_0/","text":"Mitama.Result version 6.1.0 \u00b6 New features \u00b6 Add and_finally , or_finally for basic_result Add comparison operators for maybe Add comparison operators for basic_result Enhancements \u00b6 The template parameter E is specified by default as std::monostate in maybe::ok_or(E)","title":"version 6.1.0"},{"location":"release_notes/v6_1_0/#mitamaresult_version_610","text":"","title":"Mitama.Result version 6.1.0"},{"location":"release_notes/v6_1_0/#new_features","text":"Add and_finally , or_finally for basic_result Add comparison operators for maybe Add comparison operators for basic_result","title":"New features"},{"location":"release_notes/v6_1_0/#enhancements","text":"The template parameter E is specified by default as std::monostate in maybe::ok_or(E)","title":"Enhancements"},{"location":"release_notes/v6_2_0/","text":"Mitama.Result version 6.2.0 \u00b6 New features \u00b6 in_place_factory nothing<T> - just<T>(...)","title":"version 6.2.0"},{"location":"release_notes/v6_2_0/#mitamaresult_version_620","text":"","title":"Mitama.Result version 6.2.0"},{"location":"release_notes/v6_2_0/#new_features","text":"in_place_factory nothing<T> - just<T>(...)","title":"New features"},{"location":"release_notes/v6_3_0/","text":"Mitama.Result version 6.3.0 \u00b6 Enhancements \u00b6 change return type of ok and err to maybe","title":"version 6.3.0"},{"location":"release_notes/v6_3_0/#mitamaresult_version_630","text":"","title":"Mitama.Result version 6.3.0"},{"location":"release_notes/v6_3_0/#enhancements","text":"change return type of ok and err to maybe","title":"Enhancements"},{"location":"release_notes/v6_4_0/","text":"Mitama.Result version 6.4.0 \u00b6 New features \u00b6 expect Enhancements \u00b6 Improve SFINAE tricks in map_or and map_or_else","title":"version 6.4.0"},{"location":"release_notes/v6_4_0/#mitamaresult_version_640","text":"","title":"Mitama.Result version 6.4.0"},{"location":"release_notes/v6_4_0/#new_features","text":"expect","title":"New features"},{"location":"release_notes/v6_4_0/#enhancements","text":"Improve SFINAE tricks in map_or and map_or_else","title":"Enhancements"},{"location":"release_notes/v6_4_1/","text":"Mitama.Result version 6.4.1 \u00b6 Enhancements \u00b6 Add dependent type name value_type for maybe<T> Improve SFINAE tricks in or_else for maybe","title":"version 6.4.1"},{"location":"release_notes/v6_4_1/#mitamaresult_version_641","text":"","title":"Mitama.Result version 6.4.1"},{"location":"release_notes/v6_4_1/#enhancements","text":"Add dependent type name value_type for maybe<T> Improve SFINAE tricks in or_else for maybe","title":"Enhancements"},{"location":"release_notes/v7_0_0/","text":"Mitama.Result version 7.0.0 \u00b6 New features \u00b6 Add format io for maybe Enhancements \u00b6 Replace nothing<T> with nothing Replace return type of unwrap with T& Bug fixes \u00b6 Fix compilation errors in in-place constructors Contributors \u00b6 @agate-pris @yusuke","title":"version 7.0.0"},{"location":"release_notes/v7_0_0/#mitamaresult_version_700","text":"","title":"Mitama.Result version 7.0.0"},{"location":"release_notes/v7_0_0/#new_features","text":"Add format io for maybe","title":"New features"},{"location":"release_notes/v7_0_0/#enhancements","text":"Replace nothing<T> with nothing Replace return type of unwrap with T&","title":"Enhancements"},{"location":"release_notes/v7_0_0/#bug_fixes","text":"Fix compilation errors in in-place constructors","title":"Bug fixes"},{"location":"release_notes/v7_0_0/#contributors","text":"@agate-pris @yusuke","title":"Contributors"},{"location":"release_notes/v7_0_1/","text":"Mitama.Result version 7.0.1 \u00b6 Bug fixes \u00b6 Add inline keyward to operator<< for nothing","title":"version 7.0.1"},{"location":"release_notes/v7_0_1/#mitamaresult_version_701","text":"","title":"Mitama.Result version 7.0.1"},{"location":"release_notes/v7_0_1/#bug_fixes","text":"Add inline keyward to operator<< for nothing","title":"Bug fixes"},{"location":"release_notes/v7_1_0/","text":"Mitama.Result version 7.1.0 \u00b6 New features \u00b6 and_peek / or_peek for basic_result and_peek / or_peek / or_finally for maybe","title":"version 7.1.0"},{"location":"release_notes/v7_1_0/#mitamaresult_version_710","text":"","title":"Mitama.Result version 7.1.0"},{"location":"release_notes/v7_1_0/#new_features","text":"and_peek / or_peek for basic_result and_peek / or_peek / or_finally for maybe","title":"New features"},{"location":"release_notes/v7_2_0/","text":"Mitama.Result version 7.2.0 \u00b6 New features \u00b6 Add conj / disj / xdisj for basic_result Add replace / replace_with for basic_result","title":"version 7.2.0"},{"location":"release_notes/v7_2_0/#mitamaresult_version_720","text":"","title":"Mitama.Result version 7.2.0"},{"location":"release_notes/v7_2_0/#new_features","text":"Add conj / disj / xdisj for basic_result Add replace / replace_with for basic_result","title":"New features"},{"location":"release_notes/v7_3_0/","text":"Mitama.Result version 7.3.0 \u00b6 Enhancements \u00b6 Refactoring comparison operators and adding multiple condition coverage tests","title":"version 7.3.0"},{"location":"release_notes/v7_3_0/#mitamaresult_version_730","text":"","title":"Mitama.Result version 7.3.0"},{"location":"release_notes/v7_3_0/#enhancements","text":"Refactoring comparison operators and adding multiple condition coverage tests","title":"Enhancements"},{"location":"release_notes/v7_3_1/","text":"Mitama.Result version 7.3.1 \u00b6 Bug fixes \u00b6 Fix constructor and deduction guides for maybe to accept pointers","title":"version 7.3.1"},{"location":"release_notes/v7_3_1/#mitamaresult_version_731","text":"","title":"Mitama.Result version 7.3.1"},{"location":"release_notes/v7_3_1/#bug_fixes","text":"Fix constructor and deduction guides for maybe to accept pointers","title":"Bug fixes"},{"location":"release_notes/v7_3_2/","text":"Mitama.Result version 7.3.2 \u00b6 Bug fixes \u00b6 Add a missing include directive","title":"version 7.3.2"},{"location":"release_notes/v7_3_2/#mitamaresult_version_732","text":"","title":"Mitama.Result version 7.3.2"},{"location":"release_notes/v7_3_2/#bug_fixes","text":"Add a missing include directive","title":"Bug fixes"},{"location":"release_notes/v7_4_0/","text":"Mitama.Result version 7.4.0 \u00b6 New features \u00b6 Add forward mode to just","title":"version 7.4.0"},{"location":"release_notes/v7_4_0/#mitamaresult_version_740","text":"","title":"Mitama.Result version 7.4.0"},{"location":"release_notes/v7_4_0/#new_features","text":"Add forward mode to just","title":"New features"},{"location":"release_notes/v7_5_0/","text":"Mitama.Result version 7.5.0 \u00b6 New features \u00b6 Add range_to_maybe","title":"version 7.5.0"},{"location":"release_notes/v7_5_0/#mitamaresult_version_750","text":"","title":"Mitama.Result version 7.5.0"},{"location":"release_notes/v7_5_0/#new_features","text":"Add range_to_maybe","title":"New features"},{"location":"release_notes/v7_5_1/","text":"Mitama.Result version 7.5.1 \u00b6 Bug fixes \u00b6 Fix range_to_maybe","title":"version 7.5.1"},{"location":"release_notes/v7_5_1/#mitamaresult_version_751","text":"","title":"Mitama.Result version 7.5.1"},{"location":"release_notes/v7_5_1/#bug_fixes","text":"Fix range_to_maybe","title":"Bug fixes"},{"location":"release_notes/v7_6_0/","text":"Mitama.Result version 7.7.0 \u00b6 New features \u00b6 Add panic via backtrace mode","title":"version 7.6.0"},{"location":"release_notes/v7_6_0/#mitamaresult_version_770","text":"","title":"Mitama.Result version 7.7.0"},{"location":"release_notes/v7_6_0/#new_features","text":"Add panic via backtrace mode","title":"New features"},{"location":"release_notes/v7_7_0/","text":"Mitama.Result version 7.6.0 \u00b6 Enhancements \u00b6 Replace boost::variant with std::variant","title":"version 7.7.0"},{"location":"release_notes/v7_7_0/#mitamaresult_version_760","text":"","title":"Mitama.Result version 7.6.0"},{"location":"release_notes/v7_7_0/#enhancements","text":"Replace boost::variant with std::variant","title":"Enhancements"},{"location":"release_notes/v7_8_0/","text":"Mitama.Result version 7.6.0 \u00b6 New features \u00b6 Add map_anything_else Enhancements \u00b6 maybe<T>::and_peek(F f) invokes f with successful value if f invocable with T","title":"version 7.8.0"},{"location":"release_notes/v7_8_0/#mitamaresult_version_760","text":"","title":"Mitama.Result version 7.6.0"},{"location":"release_notes/v7_8_0/#new_features","text":"Add map_anything_else","title":"New features"},{"location":"release_notes/v7_8_0/#enhancements","text":"maybe<T>::and_peek(F f) invokes f with successful value if f invocable with T","title":"Enhancements"},{"location":"release_notes/v8_0_0/","text":"Mitama.Result version 8.0.0 \u00b6 New features \u00b6 The basic_result and maybe accept references to incomplete types","title":"version 8.0.0"},{"location":"release_notes/v8_0_0/#mitamaresult_version_800","text":"","title":"Mitama.Result version 8.0.0"},{"location":"release_notes/v8_0_0/#new_features","text":"The basic_result and maybe accept references to incomplete types","title":"New features"},{"location":"release_notes/v8_1_0/","text":"Mitama.Result version 8.1.0 \u00b6 New features \u00b6 maybe<T&> and result<T&, E&> accepts abstruct reference at initialization","title":"version 8.1.0"},{"location":"release_notes/v8_1_0/#mitamaresult_version_810","text":"","title":"Mitama.Result version 8.1.0"},{"location":"release_notes/v8_1_0/#new_features","text":"maybe<T&> and result<T&, E&> accepts abstruct reference at initialization","title":"New features"},{"location":"release_notes/v8_1_1/","text":"Mitama.Result version 8.1.1 \u00b6 Bug fixes \u00b6 Some internally used metafunctions are now in the namespace","title":"version 8.1.1"},{"location":"release_notes/v8_1_1/#mitamaresult_version_811","text":"","title":"Mitama.Result version 8.1.1"},{"location":"release_notes/v8_1_1/#bug_fixes","text":"Some internally used metafunctions are now in the namespace","title":"Bug fixes"},{"location":"release_notes/v8_1_2/","text":"Mitama.Result version 8.1.2 \u00b6 Bug fixes \u00b6 Some internally used metafunctions are now in the namespace","title":"version 8.1.2"},{"location":"release_notes/v8_1_2/#mitamaresult_version_812","text":"","title":"Mitama.Result version 8.1.2"},{"location":"release_notes/v8_1_2/#bug_fixes","text":"Some internally used metafunctions are now in the namespace","title":"Bug fixes"},{"location":"release_notes/v8_1_3/","text":"Mitama.Result version 8.1.3 \u00b6 Bug fixes \u00b6 and_finally can now fix internal references.","title":"version 8.1.3"},{"location":"release_notes/v8_1_3/#mitamaresult_version_813","text":"","title":"Mitama.Result version 8.1.3"},{"location":"release_notes/v8_1_3/#bug_fixes","text":"and_finally can now fix internal references.","title":"Bug fixes"},{"location":"release_notes/v9_0_0/","text":"Mitama.Result version 9.0.0 \u00b6 Removed features \u00b6 maybe for pointers match expressions","title":"version 9.0.0"},{"location":"release_notes/v9_0_0/#mitamaresult_version_900","text":"","title":"Mitama.Result version 9.0.0"},{"location":"release_notes/v9_0_0/#removed_features","text":"maybe for pointers match expressions","title":"Removed features"},{"location":"release_notes/v9_0_1/","text":"Mitama.Result version 9.0.1 \u00b6 Bug fixes \u00b6 Fix false positive in equivalence operators for maybe Fix ICE in MSVC","title":"version 9.0.1"},{"location":"release_notes/v9_0_1/#mitamaresult_version_901","text":"","title":"Mitama.Result version 9.0.1"},{"location":"release_notes/v9_0_1/#bug_fixes","text":"Fix false positive in equivalence operators for maybe Fix ICE in MSVC","title":"Bug fixes"},{"location":"release_notes/v9_0_2/","text":"Mitama.Result version 9.0.2 \u00b6 Bug fixes \u00b6 Fix a compilation error in range_to_maybe add: bind args to monadic functions","title":"version 9.0.2"},{"location":"release_notes/v9_0_2/#mitamaresult_version_902","text":"","title":"Mitama.Result version 9.0.2"},{"location":"release_notes/v9_0_2/#bug_fixes","text":"Fix a compilation error in range_to_maybe add: bind args to monadic functions","title":"Bug fixes"},{"location":"release_notes/v9_0_3/","text":"Mitama.Result version 9.0.3 \u00b6 Enhancements \u00b6 Add bind args to monadic functions","title":"version 9.0.3"},{"location":"release_notes/v9_0_3/#mitamaresult_version_903","text":"","title":"Mitama.Result version 9.0.3"},{"location":"release_notes/v9_0_3/#enhancements","text":"Add bind args to monadic functions","title":"Enhancements"},{"location":"release_notes/v9_1_0/","text":"Mitama.Result version 9.1.0 \u00b6 New features \u00b6 Add apply_map / apply_map_err to basic_result Enhancements \u00b6 Rename: { success => success_t } and { failure => failure_t }","title":"version 9.1.0"},{"location":"release_notes/v9_1_0/#mitamaresult_version_910","text":"","title":"Mitama.Result version 9.1.0"},{"location":"release_notes/v9_1_0/#new_features","text":"Add apply_map / apply_map_err to basic_result","title":"New features"},{"location":"release_notes/v9_1_0/#enhancements","text":"Rename: { success => success_t } and { failure => failure_t }","title":"Enhancements"},{"location":"release_notes/v9_1_1/","text":"Mitama.Result version 9.1.1 \u00b6 New features \u00b6 Add map_apply / map_err_apply / and_then_apply / or_else_apply to basic_result","title":"version 9.1.1"},{"location":"release_notes/v9_1_1/#mitamaresult_version_911","text":"","title":"Mitama.Result version 9.1.1"},{"location":"release_notes/v9_1_1/#new_features","text":"Add map_apply / map_err_apply / and_then_apply / or_else_apply to basic_result","title":"New features"},{"location":"release_notes/v9_1_2/","text":"Mitama.Result version 9.1.2 \u00b6 Bug fixes \u00b6 Fix compilation errors in and_peek and or_peek Add missing overloads for map_apply_err and and_then_apply","title":"version 9.1.2"},{"location":"release_notes/v9_1_2/#mitamaresult_version_912","text":"","title":"Mitama.Result version 9.1.2"},{"location":"release_notes/v9_1_2/#bug_fixes","text":"Fix compilation errors in and_peek and or_peek Add missing overloads for map_apply_err and and_then_apply","title":"Bug fixes"},{"location":"release_notes/v9_2_0/","text":"Mitama.Result version 9.2.0 \u00b6 New features \u00b6 Add a new small library boolinators","title":"version 9.2.0"},{"location":"release_notes/v9_2_0/#mitamaresult_version_920","text":"","title":"Mitama.Result version 9.2.0"},{"location":"release_notes/v9_2_0/#new_features","text":"Add a new small library boolinators","title":"New features"},{"location":"release_notes/v9_2_1/","text":"Mitama.Result version 9.2.0 \u00b6 New features \u00b6 Add and_maybe and and_maybe_from to boolinators module","title":"version 9.2.1"},{"location":"release_notes/v9_2_1/#mitamaresult_version_920","text":"","title":"Mitama.Result version 9.2.0"},{"location":"release_notes/v9_2_1/#new_features","text":"Add and_maybe and and_maybe_from to boolinators module","title":"New features"},{"location":"release_notes/v9_3_0/","text":"Mitama.Result version 9.3.0 \u00b6 Enhancements \u00b6 Improve CMakeLists.txt #61 Improve CMakeLists.txt to be able to install include dirs Disable testing by default Fix the problem that building Result_Test.cpp fails on macOS Some improvements of CMake command usage Support void for mitama::result #72 Support superficially to be able to use void for template argument of mitama::result and functions that return void for map and map_err methods like Rust. Therefore, map and map_err methods now support to have a function as an argument that type fn(any) -> void , fn(void) -> any , and fn(void) -> void . The reason I express these changes as 'superficially' is that it converts void to std::monostate internally. New features \u00b6 Add a TRY macro like the Rust's ? operator #63 This feature is based on the language extensions of gcc and clang. It is not available for other compilers. It does not conform to the language standard and cannot be used with other compilers. anyhow and thiserror #87 anyhow is a library that can reduce the cost of writing error handling by treating error types as shared_ptr of a common base type. thiserror is a library that makes it easy to write domain-specific error types. Contributors \u00b6 ken-matsui (Collaborator) (#61, #63, #72, etc)","title":"version 9.3.0"},{"location":"release_notes/v9_3_0/#mitamaresult_version_930","text":"","title":"Mitama.Result version 9.3.0"},{"location":"release_notes/v9_3_0/#enhancements","text":"Improve CMakeLists.txt #61 Improve CMakeLists.txt to be able to install include dirs Disable testing by default Fix the problem that building Result_Test.cpp fails on macOS Some improvements of CMake command usage Support void for mitama::result #72 Support superficially to be able to use void for template argument of mitama::result and functions that return void for map and map_err methods like Rust. Therefore, map and map_err methods now support to have a function as an argument that type fn(any) -> void , fn(void) -> any , and fn(void) -> void . The reason I express these changes as 'superficially' is that it converts void to std::monostate internally.","title":"Enhancements"},{"location":"release_notes/v9_3_0/#new_features","text":"Add a TRY macro like the Rust's ? operator #63 This feature is based on the language extensions of gcc and clang. It is not available for other compilers. It does not conform to the language standard and cannot be used with other compilers. anyhow and thiserror #87 anyhow is a library that can reduce the cost of writing error handling by treating error types as shared_ptr of a common base type. thiserror is a library that makes it easy to write domain-specific error types.","title":"New features"},{"location":"release_notes/v9_3_0/#contributors","text":"ken-matsui (Collaborator) (#61, #63, #72, etc)","title":"Contributors"},{"location":"result/APIs/","text":"API reference \u00b6 is_ok \u00b6 basic_result<_, T, E> \u2192 bool Returns true if the result is success . declarations template < mutability _mu , class T , class E > class basic_result { constexpr bool is_ok () const noexcept ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_ok () == true ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_ok () == false ); } // end example is_err \u00b6 basic_result<_, T, E> \u2192 bool Returns true if the result is failure. declarations template < mutability _mu , class T , class E > class basic_result { constexpr bool is_err () const noexcept ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_err () == false ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_err () == true ); } // end example ok \u00b6 basic_result<_, T, E> \u2192 maybe<T> Converts from basic_result to maybe . Converts self into a maybe , and discarding the failure value, if any. Note that these functions propagate mutability to element type of maybe . Remarks If self is rvalue and T is a reference type, this function returns maybe<dangling<std::reference_wrapper<std::remove_reference_t<T>>>> . declarations template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: ok () & -> maybe < const T > ; constexpr auto result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto result < T , E >:: ok () && -> maybe < const T > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: ok () & -> maybe < T > ; constexpr auto mut_result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () && -> maybe < T > ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == just ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . ok () == nothing ); } // end example err \u00b6 basic_result<_, T, E> \u2192 maybe<E> Converts from basic_result to maybe . Converts self into a maybe , and discarding the success value, if any. Note that these functions propagate mutability to element type of maybe . remarks If self is rvalue and E is a reference type, this function returns maybe<dangling<std::reference_wrapper<std::remove_reference_t<E>>>> . declarations template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: err () & -> maybe < const E > ; constexpr auto result < T , E >:: err () const & -> maybe < const E > ; constexpr auto result < T , E >:: err () && -> maybe < const E > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: err () & -> maybe < E > ; constexpr auto mut_result < T , E >:: err () const & -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () && -> maybe < E > ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == nothing ); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . err () == just ( \"Nothing here\" s )); } // end example map \u00b6 basic_result< , T, E> \u2192 O \u2192 basic_result< , U, E> Maps a result<T, E> to result<U, E> by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. constraints requires std :: invocable < O , T > declarations template < mutability _mu , class T , class E > class basic_result { constexpr auto map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> #include <boost/lambda/lambda.hpp> using namespace mitama ; using namespace std :: string_literals ; using boost :: lambda :: _1 ; int main () { result < int , int > ok = success ( 2 ); assert ( ok . map ( _1 * 2 ) == success ( 4 )); result < int , int > err = failure ( 2 ); assert ( err . map ( _1 * 2 ) == failure ( 2 )); } // end example map_or_else \u00b6 basic_result<_, T, E> \u2192 Fallback \u2192 Map \u2192 U, where Fallback: E \u2192 U, Map: T \u2192 U Maps a result<T, E> to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. constraints requires { typename std :: common_type < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E > >:: type ; } declarations template < mutability _mu , class T , class E > class basic_result { template < class Map , class Fallback > constexpr auto map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; }; Examples \u00b6 Basic usages: // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); } } // end example map_anything_else [since v7.8.0] \u00b6 basic_result<_, T, E> \u2192 Map \u2192 U, where \u2002Map: T \u2192 U, \u2002Map: E \u2192 U Maps a result<T, E> to U by applying a function _map to a contained either success or failure value. This function is syntax sugar for res.map_or_else(_map, _map) . constraints requires ( Map map , T ok , E err ) { { map ( ok ) }; { map ( err ) }; typename std :: common_type < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Map , E > >:: type ; } declarations template < mutability _mu , class T , class E > class basic_result { template < class Map > constexpr auto map_or_else ( Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; }; Examples \u00b6 Basic usage: // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_anything_else ([]( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_anything_else ([]( auto v ) { return v . length (); }) == 3 ); } } // end example map_err \u00b6 basic_result< , T, E> \u2192 O \u2192 basic_result< , T, F> where O: E -> F Maps a result<T, E> to result<T, F> by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. constraints requires ( O && op , E err ) { typename std :: invoke_result < O && , E >:: type ; } declarations template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert ( x . map_err ( stringify ) == success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert ( y . map_err ( stringify ) == failure ( \"error code: 13\" s )); } // end example conj \u00b6 basic_result< , T, E> \u2192 basic_result< , U, E> \u2192 basic_result<_, U, E> self.conj(res) returns res if the result is success , otherwise returns the failure value of self. declarations template < mutability _mu , class T , class E > class basic_result { template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: conj ( basic_result < _ , U , E > const & ) const & -> basic_result < U , E > ; template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & ) const & -> basic_result < U , E > ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); } } // end example and_then \u00b6 basic_result< , T, E> \u2192 O \u2192 basic_result< , U, E>, where O: T \u2192 basic_result<_, U, E> self.and_then(op) calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. constraints requires ( is_result_v < std :: invoke_result_t < O , T >> and std :: convertible_to < typename std :: invoke_result_t < O , T >:: err_type , E > ) declarations template < mutability _mu , class T , class E > class basic_result { template < class O , std :: enable_of > constexpr auto and_then ( O && op ) & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) const & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T const &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) && -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &&> , failure < E >> , std :: invoke_result_t < O , T >> ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( x . and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( x . and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( y . and_then ( sq ). and_then ( sq ) == failure ( 3u )); } // end example disj \u00b6 basic_result< , T, E> \u2192 basic_result< , T, F> \u2192 basic_result<_, T, F> self.disj(res) returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr auto basic_result < _ , T , E >:: disj ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == failure ( \"late error\" s )); assert (( x || y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } } // end example or_else \u00b6 basic_result< , T, E> \u2192 O \u2192 basic_result< , T, F>, where O: E -> basic_result<_, T, F> self.or_else(op) calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. constraints requires ( is_result_v < std :: invoke_result_t < O , T >> and std :: convertible_to < typename std :: invoke_result_t < O , T >:: ok_type , T > ) declarations template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . or_else ( sq ). or_else ( sq ) == success ( 2u )); assert ( x . or_else ( err ). or_else ( sq ) == success ( 2u )); assert ( y . or_else ( sq ). or_else ( err ) == success ( 9u )); assert ( y . or_else ( err ). or_else ( err ) == failure ( 3u )); } // end example unwrap_or \u00b6 basic_result<_, T, E> \u2192 T const& \u2192 T self.unwrap_or(optb) unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. declarations template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , unsigned > ok = success ( 2 ); result < unsigned , unsigned > err = failure ( 2 ); assert ( ok . unwrap_or ( 1u ) == 2u ); assert ( err . unwrap_or ( 1u ) == 1u ); } // end example unwrap_or_else \u00b6 basic_result<_, T, E> \u2192 O \u2192 T, where O: E \u2192 T self.unwrap_or_else(op) unwraps a result, yielding the content of an success . If the value is an failure then it invokes op with its value. constraints requires ( O && op , E err ) { { std :: invoke ( op , err ) } -> std :: convertible_to < T > ; } declarations template < mutability _mu , class T , class E > class basic_result { template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int , std :: string > ok = success ( 2 ); result < int , std :: string > err = failure ( \"foo\" s ); assert ( ok . unwrap_or_else ( & std :: string :: size ) == 2 ); assert ( err . unwrap_or_else ( & std :: string :: size ) == 3 ); } // end example unwrap \u00b6 basic_result<_, T, E> \u2192 E Unwraps a result, yielding the content of an success . exceptions Raise mitama::runtime_panic if a result is containing failure value. remarks If self is rvalue and T is a reference type, this function returns maybe<dangling<std::reference_wrapper<std::remove_reference_t<T>>>> . declarations template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap () & -> const T ; auto unwrap () const & -> const T ; auto unwrap () && -> const T ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto unwrap () & -> T ; auto unwrap () const & -> const T ; auto unwrap () && -> T ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); assert ( x . unwrap () == 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } } // end example unwrap_err \u00b6 basic_result<_, T, E> \u2192 E Unwraps a result, yielding the content of an failure . exceptions Raise mitama::runtime_panic if a result is containing success value. remarks If self is rvalue and E is a reference type, this function returns maybe<dangling<std::reference_wrapper<std::remove_reference_t<E>>>> . declarations template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap_err () & -> const E ; auto unwrap_err () const & -> const E ; auto unwrap_err () && -> const E ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto mut_unwrap_err () & -> E ; auto mut_unwrap_err () const & -> const E ; auto mut_unwrap_err () && -> E ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert ( x . unwrap_err () == \"emergency failure\" s ); } } // end example unwrap_or_default \u00b6 basic_result<_, T, E> \u2192 T Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. constraints requires std :: default_initializable < T > remarks This operator shall be defined as deleted unless is_default_constructible_v<T> is true. declarations template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int > good = success ( 1909 ); result < int > bad = failure <> (); auto good_year = good . unwrap_or_default (); auto bad_year = bad . unwrap_or_default (); assert ( 1909 == good_year ); assert ( 0 == bad_year ); } // end example transpose \u00b6 basic_result< , maybe&ltT>, E> \u2192 maybe<basic_result< , T, E>> Transposes a result of a maybe into a maybe of a result . success(nothing) will be mapped to nothing . success(just(v)) and failure(v) will be mapped to just(success(v)) and just(failure(v)) . declarations template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x . transpose () == y ); } // end example and_finally \u00b6 basic_result<T, E> \u2192 F \u2192 void Invokes the provided function with the contained success value (if success), or doing nothing (if failure). The return value of F will be discarded whether void or not. declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , ok_type $ { CVREF } >> and_finally ( F && f ) $ { CVREF } }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; x . and_finally ([ & ]( int const & v ){ hook = v ; }); assert ( hook == 42 ); } // end example or_finally \u00b6 basic_result<T, E> \u2192 F \u2192 void Invokes the provided function with contained failure value (if failure), or doing nothing (if success). The return value of F will be discarded whether void or not. declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , err_type $ { CVREF } >> and_finally ( F && f ) $ { CVREF } }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <string> #include <cassert> using namespace mitama ; int main () { using namespace std :: literals ; std :: string hook = \"default\" ; result < int , std :: string > x = success ( 42 ); x . or_finally ([ & hook ]( std :: string v ){ hook = v ; }); assert ( hook == \"default\" s ); result < int , std :: string > y = failure ( \"error\" s ); y . or_finally ([ & hook ]( std :: string v ){ hook = v ; }); assert ( hook == \"error\" s ); } // end example and_peek \u00b6 basic_result<T, E> \u2192 F \u2192 basic_result<T, E> Peeks the contained success value and then returns self. Invokes the provided function with the contained value and then return self (if success), or return self without doing anything (if failure). declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , ok_type $ { CVREF } > , std :: is_invocable < F >> , basic_result &> and_peek ( F && f ) $ { CVREF } }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == success ( 42 )); assert ( hook == 42 ); } // end example or_peek \u00b6 basic_result<T, E> \u2192 F \u2192 basic_result<T, E> Peeks the contained failure value and then returns self. Invokes the provided function and then return self (if failure), or return self without doing anything (if success). declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , err_type $ { CVREF } > , std :: is_invocable < F >> , basic_result &> or_peek ( F && f ) $ { CVREF } }; Examples \u00b6 // begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"API Reference"},{"location":"result/APIs/#api_reference","text":"","title":"API reference"},{"location":"result/APIs/#is_ok","text":"basic_result<_, T, E> \u2192 bool Returns true if the result is success . declarations template < mutability _mu , class T , class E > class basic_result { constexpr bool is_ok () const noexcept ; };","title":"is_ok"},{"location":"result/APIs/#examples","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_ok () == true ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_ok () == false ); } // end example","title":"Examples"},{"location":"result/APIs/#is_err","text":"basic_result<_, T, E> \u2192 bool Returns true if the result is failure. declarations template < mutability _mu , class T , class E > class basic_result { constexpr bool is_err () const noexcept ; };","title":"is_err"},{"location":"result/APIs/#examples_1","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 3 ); assert ( x . is_err () == false ); result < unsigned , std :: string > y = failure ( \"Some error message\" s ); assert ( y . is_err () == true ); } // end example","title":"Examples"},{"location":"result/APIs/#ok","text":"basic_result<_, T, E> \u2192 maybe<T> Converts from basic_result to maybe . Converts self into a maybe , and discarding the failure value, if any. Note that these functions propagate mutability to element type of maybe . Remarks If self is rvalue and T is a reference type, this function returns maybe<dangling<std::reference_wrapper<std::remove_reference_t<T>>>> . declarations template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: ok () & -> maybe < const T > ; constexpr auto result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto result < T , E >:: ok () && -> maybe < const T > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: ok () & -> maybe < T > ; constexpr auto mut_result < T , E >:: ok () const & -> maybe < const T > ; constexpr auto mut_result < T , E >:: ok () && -> maybe < T > ; };","title":"ok"},{"location":"result/APIs/#examples_2","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . ok () == just ( 2 )); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . ok () == nothing ); } // end example","title":"Examples"},{"location":"result/APIs/#err","text":"basic_result<_, T, E> \u2192 maybe<E> Converts from basic_result to maybe . Converts self into a maybe , and discarding the success value, if any. Note that these functions propagate mutability to element type of maybe . remarks If self is rvalue and E is a reference type, this function returns maybe<dangling<std::reference_wrapper<std::remove_reference_t<E>>>> . declarations template < class T , class E > class basic_result < mutability :: immut , T , E > { constexpr auto result < T , E >:: err () & -> maybe < const E > ; constexpr auto result < T , E >:: err () const & -> maybe < const E > ; constexpr auto result < T , E >:: err () && -> maybe < const E > ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { constexpr auto mut_result < T , E >:: err () & -> maybe < E > ; constexpr auto mut_result < T , E >:: err () const & -> maybe < const E > ; constexpr auto mut_result < T , E >:: err () && -> maybe < E > ; };","title":"err"},{"location":"result/APIs/#examples_3","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , std :: string > x = success ( 2 ); assert ( x . err () == nothing ); result < unsigned , std :: string > y = failure ( \"Nothing here\" s ); assert ( y . err () == just ( \"Nothing here\" s )); } // end example","title":"Examples"},{"location":"result/APIs/#map","text":"basic_result< , T, E> \u2192 O \u2192 basic_result< , U, E> Maps a result<T, E> to result<U, E> by applying a function to a contained success value, leaving an failure value untouched. This function can be used to compose the results of two functions. constraints requires std :: invocable < O , T > declarations template < mutability _mu , class T , class E > class basic_result { constexpr auto map ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , T > , result < std :: invoke_result_t < O , T > , E >> ; };","title":"map"},{"location":"result/APIs/#examples_4","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> #include <boost/lambda/lambda.hpp> using namespace mitama ; using namespace std :: string_literals ; using boost :: lambda :: _1 ; int main () { result < int , int > ok = success ( 2 ); assert ( ok . map ( _1 * 2 ) == success ( 4 )); result < int , int > err = failure ( 2 ); assert ( err . map ( _1 * 2 ) == failure ( 2 )); } // end example","title":"Examples"},{"location":"result/APIs/#map_or_else","text":"basic_result<_, T, E> \u2192 Fallback \u2192 Map \u2192 U, where Fallback: E \u2192 U, Map: T \u2192 U Maps a result<T, E> to U by applying a function to a contained success value, or a fallback function to a contained failure value. This function can be used to unpack a successful result while handling an error. constraints requires { typename std :: common_type < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E > >:: type ; } declarations template < mutability _mu , class T , class E > class basic_result { template < class Map , class Fallback > constexpr auto map_or_else ( Fallback && _fallback , Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; };","title":"map_or_else"},{"location":"result/APIs/#examples_5","text":"Basic usages: // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto k = 21 ; { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_or_else ([ k ]( auto ){ return k * 2 ; }, []( auto v ) { return v . length (); }) == 42 ); } } // end example","title":"Examples"},{"location":"result/APIs/#map_anything_else_since_v780","text":"basic_result<_, T, E> \u2192 Map \u2192 U, where \u2002Map: T \u2192 U, \u2002Map: E \u2192 U Maps a result<T, E> to U by applying a function _map to a contained either success or failure value. This function is syntax sugar for res.map_or_else(_map, _map) . constraints requires ( Map map , T ok , E err ) { { map ( ok ) }; { map ( err ) }; typename std :: common_type < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Map , E > >:: type ; } declarations template < mutability _mu , class T , class E > class basic_result { template < class Map > constexpr auto map_or_else ( Map && _map ) const & -> std :: common_type_t < std :: invoke_result_t < Map , T > , std :: invoke_result_t < Fallback , E >> ; };","title":"map_anything_else [since v7.8.0]"},{"location":"result/APIs/#examples_6","text":"Basic usage: // begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < std :: string , std :: string > x = success ( \"foo\" s ); assert ( x . map_anything_else ([]( auto v ) { return v . length (); }) == 3 ); } { result < std :: string , std :: string > x = failure ( \"bar\" s ); assert ( x . map_anything_else ([]( auto v ) { return v . length (); }) == 3 ); } } // end example","title":"Examples"},{"location":"result/APIs/#map_err","text":"basic_result< , T, E> \u2192 O \u2192 basic_result< , T, F> where O: E -> F Maps a result<T, E> to result<T, F> by applying a function to a contained failure value, leaving an success value untouched. This function can be used to pass through a successful result while handling an error. constraints requires ( O && op , E err ) { typename std :: invoke_result < O && , E >:: type ; } declarations template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto map_err ( O && op ) const & -> std :: enable_if_t < std :: is_invocable_v < O , E > , result < T , std :: invoke_result_t < O , E >>> ; };","title":"map_err"},{"location":"result/APIs/#examples_7","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto stringify = []( unsigned x ) -> std :: string { return \"error code: \" s + std :: to_string ( x ); }; result < unsigned , unsigned > x = success ( 2 ); assert ( x . map_err ( stringify ) == success ( 2u )); result < unsigned , unsigned > y = failure ( 13 ); assert ( y . map_err ( stringify ) == failure ( \"error code: 13\" s )); } // end example","title":"Examples"},{"location":"result/APIs/#conj","text":"basic_result< , T, E> \u2192 basic_result< , U, E> \u2192 basic_result<_, U, E> self.conj(res) returns res if the result is success , otherwise returns the failure value of self. declarations template < mutability _mu , class T , class E > class basic_result { template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: conj ( basic_result < _ , U , E > const & ) const & -> basic_result < U , E > ; template < mutability _ , class U > constexpr auto basic_result < _ , T , E >:: operator && ( basic_result < _ , U , E > const & ) const & -> basic_result < U , E > ; };","title":"conj"},{"location":"result/APIs/#examples_8","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < std :: string , std :: string > y = success ( \"foo\" s ); assert (( x && y ) == failure ( \"early error\" s )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < std :: string , std :: string > y = failure ( \"late error\" s ); assert (( x && y ) == failure ( \"not a 2\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < std :: string , std :: string > y = success ( \"different result type\" s ); assert (( x && y ) == success ( \"different result type\" s )); } } // end example","title":"Examples"},{"location":"result/APIs/#and_then","text":"basic_result< , T, E> \u2192 O \u2192 basic_result< , U, E>, where O: T \u2192 basic_result<_, U, E> self.and_then(op) calls op if the result is success, otherwise returns the failure value of self. This function can be used for control flow based on result values. constraints requires ( is_result_v < std :: invoke_result_t < O , T >> and std :: convertible_to < typename std :: invoke_result_t < O , T >:: err_type , E > ) declarations template < mutability _mu , class T , class E > class basic_result { template < class O , std :: enable_of > constexpr auto and_then ( O && op ) & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) const & -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T const &> , failure < E >> , std :: invoke_result_t < O , T >> ; template < class O > constexpr auto and_then ( O && op ) && -> std :: enable_if_t < is_convertible_result_with_v < std :: invoke_result_t < O && , T &&> , failure < E >> , std :: invoke_result_t < O , T >> ; };","title":"and_then"},{"location":"result/APIs/#examples_9","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . and_then ( sq ). and_then ( sq ) == success ( 16u )); assert ( x . and_then ( sq ). and_then ( err ) == failure ( 4u )); assert ( x . and_then ( err ). and_then ( sq ) == failure ( 2u )); assert ( y . and_then ( sq ). and_then ( sq ) == failure ( 3u )); } // end example","title":"Examples"},{"location":"result/APIs/#disj","text":"basic_result< , T, E> \u2192 basic_result< , T, F> \u2192 basic_result<_, T, F> self.disj(res) returns res if the result is failure , otherwise returns the success value of self. Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use or_else , which is lazily evaluated. declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr auto basic_result < _ , T , E >:: disj ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; template < class F > constexpr auto basic_result < _ , T , E >:: operator || ( basic_result < _ , T , F > const & res ) const & -> basic_result < _ , T , F > ; };","title":"disj"},{"location":"result/APIs/#examples_10","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"early error\" s ); result < unsigned , std :: string > y = success ( 2 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } { result < unsigned , std :: string > x = failure ( \"not a 2\" s ); result < unsigned , std :: string > y = failure ( \"late error\" s ); assert ( x . disj ( y ) == failure ( \"late error\" s )); assert (( x || y ) == failure ( \"late error\" s )); } { result < unsigned , std :: string > x = success ( 2 ); result < unsigned , std :: string > y = success ( 100 ); assert ( x . disj ( y ) == success ( 2u )); assert (( x || y ) == success ( 2u )); } } // end example","title":"Examples"},{"location":"result/APIs/#or_else","text":"basic_result< , T, E> \u2192 O \u2192 basic_result< , T, F>, where O: E -> basic_result<_, T, F> self.or_else(op) calls op if the result is failure , otherwise returns the success value of self. This function can be used for control flow based on result values. constraints requires ( is_result_v < std :: invoke_result_t < O , T >> and std :: convertible_to < typename std :: invoke_result_t < O , T >:: ok_type , T > ) declarations template < mutability _mu , class T , class E > class basic_result { template < class O > constexpr auto basic_result < _ , T , E >:: or_else ( O && op ) const & -> std :: invoke_result < O && , E > ; };","title":"or_else"},{"location":"result/APIs/#examples_11","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { auto sq = []( unsigned x ) -> result < unsigned , unsigned > { return success ( x * x ); }; auto err = []( unsigned x ) -> result < unsigned , unsigned > { return failure ( x ); }; result < int , int > x = success ( 2u ); result < int , int > y = failure ( 3u ); assert ( x . or_else ( sq ). or_else ( sq ) == success ( 2u )); assert ( x . or_else ( err ). or_else ( sq ) == success ( 2u )); assert ( y . or_else ( sq ). or_else ( err ) == success ( 9u )); assert ( y . or_else ( err ). or_else ( err ) == failure ( 3u )); } // end example","title":"Examples"},{"location":"result/APIs/#unwrap_or","text":"basic_result<_, T, E> \u2192 T const& \u2192 T self.unwrap_or(optb) unwraps a result, yielding the content of an success . Else, it returns optb . Arguments passed to unwrap_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use unwrap_or_else , which is lazily evaluated. declarations template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or ( T const & optb ) const noexcept };","title":"unwrap_or"},{"location":"result/APIs/#examples_12","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < unsigned , unsigned > ok = success ( 2 ); result < unsigned , unsigned > err = failure ( 2 ); assert ( ok . unwrap_or ( 1u ) == 2u ); assert ( err . unwrap_or ( 1u ) == 1u ); } // end example","title":"Examples"},{"location":"result/APIs/#unwrap_or_else","text":"basic_result<_, T, E> \u2192 O \u2192 T, where O: E \u2192 T self.unwrap_or_else(op) unwraps a result, yielding the content of an success . If the value is an failure then it invokes op with its value. constraints requires ( O && op , E err ) { { std :: invoke ( op , err ) } -> std :: convertible_to < T > ; } declarations template < mutability _mu , class T , class E > class basic_result { template < class O > auto basic_result < _ , T , E >:: unwrap_or_else ( O && op ) const noexcept -> std :: enable_if_t < std :: is_invocable_r_v < T , O , E > , T > ; };","title":"unwrap_or_else"},{"location":"result/APIs/#examples_13","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int , std :: string > ok = success ( 2 ); result < int , std :: string > err = failure ( \"foo\" s ); assert ( ok . unwrap_or_else ( & std :: string :: size ) == 2 ); assert ( err . unwrap_or_else ( & std :: string :: size ) == 3 ); } // end example","title":"Examples"},{"location":"result/APIs/#unwrap","text":"basic_result<_, T, E> \u2192 E Unwraps a result, yielding the content of an success . exceptions Raise mitama::runtime_panic if a result is containing failure value. remarks If self is rvalue and T is a reference type, this function returns maybe<dangling<std::reference_wrapper<std::remove_reference_t<T>>>> . declarations template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap () & -> const T ; auto unwrap () const & -> const T ; auto unwrap () && -> const T ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto unwrap () & -> T ; auto unwrap () const & -> const T ; auto unwrap () && -> T ; };","title":"unwrap"},{"location":"result/APIs/#examples_14","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { { result < unsigned , std :: string > x = success ( 2 ); assert ( x . unwrap () == 2 ); } try { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); x . unwrap (); // panics with `emergency failure` } catch ( mitama :: runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } } // end example","title":"Examples"},{"location":"result/APIs/#unwrap_err","text":"basic_result<_, T, E> \u2192 E Unwraps a result, yielding the content of an failure . exceptions Raise mitama::runtime_panic if a result is containing success value. remarks If self is rvalue and E is a reference type, this function returns maybe<dangling<std::reference_wrapper<std::remove_reference_t<E>>>> . declarations template < class T , class E > class basic_result < mutability :: immut , T , E > { auto unwrap_err () & -> const E ; auto unwrap_err () const & -> const E ; auto unwrap_err () && -> const E ; }; template < class T , class E > class basic_result < mutability :: mut , T , E > { auto mut_unwrap_err () & -> E ; auto mut_unwrap_err () const & -> const E ; auto mut_unwrap_err () && -> E ; };","title":"unwrap_err"},{"location":"result/APIs/#examples_15","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { try { result < unsigned , std :: string > x = success ( 2 ); x . unwrap_err (); // panics with `2` } catch ( runtime_panic const & panic ) { std :: cerr << panic . what () << std :: endl ; } { result < unsigned , std :: string > x = failure ( \"emergency failure\" s ); assert ( x . unwrap_err () == \"emergency failure\" s ); } } // end example","title":"Examples"},{"location":"result/APIs/#unwrap_or_default","text":"basic_result<_, T, E> \u2192 T Returns the contained value or a default. If success , returns the contained value, otherwise if failure , returns the default value for that type. constraints requires std :: default_initializable < T > remarks This operator shall be defined as deleted unless is_default_constructible_v<T> is true. declarations template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , T , E >:: unwrap_or_default () const & -> T ; };","title":"unwrap_or_default"},{"location":"result/APIs/#examples_16","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; using namespace std :: string_literals ; int main () { result < int > good = success ( 1909 ); result < int > bad = failure <> (); auto good_year = good . unwrap_or_default (); auto bad_year = bad . unwrap_or_default (); assert ( 1909 == good_year ); assert ( 0 == bad_year ); } // end example","title":"Examples"},{"location":"result/APIs/#transpose","text":"basic_result< , maybe&ltT>, E> \u2192 maybe<basic_result< , T, E>> Transposes a result of a maybe into a maybe of a result . success(nothing) will be mapped to nothing . success(just(v)) and failure(v) will be mapped to just(success(v)) and just(failure(v)) . declarations template < mutability _mu , class T , class E > class basic_result { auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; auto basic_result < _ , maybe < T > , E >:: transpose () -> maybe < basic_result < _ , T , E >> ; };","title":"transpose"},{"location":"result/APIs/#examples_17","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> #include <string> using namespace mitama ; int main () { result < maybe < int > , std :: string > x = success ( just ( 5 )); maybe < result < int , std :: string >> y = just ( success ( 5 )); assert ( x . transpose () == y ); } // end example","title":"Examples"},{"location":"result/APIs/#and_finally","text":"basic_result<T, E> \u2192 F \u2192 void Invokes the provided function with the contained success value (if success), or doing nothing (if failure). The return value of F will be discarded whether void or not. declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , ok_type $ { CVREF } >> and_finally ( F && f ) $ { CVREF } };","title":"and_finally"},{"location":"result/APIs/#examples_18","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; x . and_finally ([ & ]( int const & v ){ hook = v ; }); assert ( hook == 42 ); } // end example","title":"Examples"},{"location":"result/APIs/#or_finally","text":"basic_result<T, E> \u2192 F \u2192 void Invokes the provided function with contained failure value (if failure), or doing nothing (if success). The return value of F will be discarded whether void or not. declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: is_invocable_v < F && , err_type $ { CVREF } >> and_finally ( F && f ) $ { CVREF } };","title":"or_finally"},{"location":"result/APIs/#examples_19","text":"// begin example #include <mitama/result/result.hpp> #include <string> #include <cassert> using namespace mitama ; int main () { using namespace std :: literals ; std :: string hook = \"default\" ; result < int , std :: string > x = success ( 42 ); x . or_finally ([ & hook ]( std :: string v ){ hook = v ; }); assert ( hook == \"default\" s ); result < int , std :: string > y = failure ( \"error\" s ); y . or_finally ([ & hook ]( std :: string v ){ hook = v ; }); assert ( hook == \"error\" s ); } // end example","title":"Examples"},{"location":"result/APIs/#and_peek","text":"basic_result<T, E> \u2192 F \u2192 basic_result<T, E> Peeks the contained success value and then returns self. Invokes the provided function with the contained value and then return self (if success), or return self without doing anything (if failure). declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , ok_type $ { CVREF } > , std :: is_invocable < F >> , basic_result &> and_peek ( F && f ) $ { CVREF } };","title":"and_peek"},{"location":"result/APIs/#examples_20","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { result < int , std :: string > x = success ( 42 ); int hook = 0 ; assert ( x . and_peek ([ & ]( int const & v ){ hook = v ; }) == success ( 42 )); assert ( hook == 42 ); } // end example","title":"Examples"},{"location":"result/APIs/#or_peek","text":"basic_result<T, E> \u2192 F \u2192 basic_result<T, E> Peeks the contained failure value and then returns self. Invokes the provided function and then return self (if failure), or return self without doing anything (if success). declarations template < mutability _mu , class T , class E > class basic_result { template < class F > constexpr std :: enable_if_t < std :: disjunction_v < std :: is_invocable < F , err_type $ { CVREF } > , std :: is_invocable < F >> , basic_result &> or_peek ( F && f ) $ { CVREF } };","title":"or_peek"},{"location":"result/APIs/#examples_21","text":"// begin example #include <mitama/result/result.hpp> #include <cassert> using namespace mitama ; int main () { maybe x = nothing ; int hook = 0 ; assert ( x . or_peek ([ & ]{ hook = 42 ; }) == nothing ); assert ( hook == 42 ); } // end example","title":"Examples"},{"location":"result/CHANGELOG/","text":"CHANGELOG \u00b6 v5.0.0 (breaking change!) Types \u00b6 basic_result { Result<T, E> => basic_result<mutability, T, E> } Enabled lvalue reference types for both of T and E result<T, E> the alias template for immutable basic_result mut_result<T, E> the alias template for mutable basic_result success { Ok<T> => success<T> } Enabled lvalue reference types for T . failure { Err<E> => failure<E> } Enabled lvalue reference types for E . New APIs \u00b6 as_ref() as_mut() indirect() indirect_ok() indirect_err() v1.2.0 enhancement \u00b6 new API: transpose new API: map_or_else v1.1.2 bug fix \u00b6 Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result<U, E> . std::invoke_result_t<O&&, T> must be returns Result<U, E> . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result<T, F> . std::invoke_result_t<O&&, E> must be returns Result<T, F> . It means op must only maps E -> F , never changes T . v1.1.1 bug fix \u00b6 Result ::unwrap_or_default() is now explicitly deleted if and only if std::is_default_constructible_v<T> || std::is_aggregate_v<T> is false.","title":"CHANGELOG"},{"location":"result/CHANGELOG/#changelog","text":"v5.0.0 (breaking change!)","title":"CHANGELOG"},{"location":"result/CHANGELOG/#types","text":"basic_result { Result<T, E> => basic_result<mutability, T, E> } Enabled lvalue reference types for both of T and E result<T, E> the alias template for immutable basic_result mut_result<T, E> the alias template for mutable basic_result success { Ok<T> => success<T> } Enabled lvalue reference types for T . failure { Err<E> => failure<E> } Enabled lvalue reference types for E .","title":"Types"},{"location":"result/CHANGELOG/#new_apis","text":"as_ref() as_mut() indirect() indirect_ok() indirect_err() v1.2.0","title":"New APIs"},{"location":"result/CHANGELOG/#enhancement","text":"new API: transpose new API: map_or_else v1.1.2","title":"enhancement"},{"location":"result/CHANGELOG/#bug_fix","text":"Result ::and_then(O&& op) do not perticipate in overload resolution if unless op returns Result<U, E> . std::invoke_result_t<O&&, T> must be returns Result<U, E> . It means op must only maps T -> U , never changes E . Result ::or_else(O&& op) do not perticipate in overload resolution if unless op returns Result<T, F> . std::invoke_result_t<O&&, E> must be returns Result<T, F> . It means op must only maps E -> F , never changes T . v1.1.1","title":"bug fix"},{"location":"result/CHANGELOG/#bug_fix_1","text":"Result ::unwrap_or_default() is now explicitly deleted if and only if std::is_default_constructible_v<T> || std::is_aggregate_v<T> is false.","title":"bug fix"},{"location":"result/comparisons/","text":"operator==, !=, <, <=, >, >=(basic_result) \u00b6 namespace mitama { // Compare two basic_result objects template < class T , class E , class U , class F > constexpr bool operator == ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (1) template < class T , class E , class U , class F > constexpr bool operator != ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (2) template < class T , class E , class U , class F > constexpr bool operator < ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (3) template < class T , class E , class U , class F > constexpr bool operator <= ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (4) template < class T , class E , class U , class F > constexpr bool operator > ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (5) template < class T , class E , class U , class F > constexpr bool operator >= ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (6) // Compare a basic_result object with a success(value) template < class T , class E , class U > constexpr bool operator == ( const basic_result < T , E >& res , success < U > const & ok ); // (7) template < class T , class E , class U > constexpr bool operator == ( success < T > const & ok , const basic_result < U , E >& res ); // (8) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , success < U > const & ok ); // (9) template < class T , class E , class U > constexpr bool operator != ( success < T > const & ok , const basic_result < U , E >& res ); // (10) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , success < U > const & ok ); // (11) template < class T , class E , class U > constexpr bool operator < ( success < T > const & ok , const basic_result < U , E >& res ); // (12) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , success < U > const & ok ); // (13) template < class T , class E , class U > constexpr bool operator <= ( success < T > const & ok , const basic_result < U , E >& res ); // (14) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , success < U > const & ok ); // (15) template < class T , class E , class U > constexpr bool operator > ( success < T > const & ok , const basic_result < U , E >& res ); // (16) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , success < U > const & ok ); // (17) template < class T , class E , class U > constexpr bool operator >= ( success < T > const & ok , const basic_result < U , E >& res ); // (18) // Compare a basic_result object with a failure(value) template < class T , class E , class F > constexpr bool operator == ( const basic_result < T , E >& res , failure < F > const & err ); // (19) template < class T , class E , class U > constexpr bool operator == ( failure < E > const & err , const basic_result < T , F >& res ); // (20) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , failure < F > const & err ); // (21) template < class T , class E , class U > constexpr bool operator != ( failure < E > const & err , const basic_result < T , F >& res ); // (22) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , failure < F > const & err ); // (23) template < class T , class E , class U > constexpr bool operator < ( failure < E > const & err , const basic_result < T , F >& res ); // (24) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , failure < F > const & err ); // (25) template < class T , class E , class U > constexpr bool operator <= ( failure < E > const & err , const basic_result < T , F >& res ); // (26) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , failure < F > const & err ); // (27) template < class T , class E , class U > constexpr bool operator > ( failure < E > const & err , const basic_result < T , F >& res ); // (28) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , failure < F > const & err ); // (29) template < class T , class E , class U > constexpr bool operator >= ( failure < E > const & err , const basic_result < T , F >& res ); // (30) // Compare a basic_result object with a T template < class T , class E , class U > constexpr bool operator == ( const basic_result < T , E >& res , const U & value ); // (31) template < class T , class E , class U > constexpr bool operator == ( const T & value , const basic_result < U , E >& res ); // (32) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , const U & value ); // (33) template < class T , class E , class U > constexpr bool operator != ( const T & value , const basic_result < U , E >& res ); // (34) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , const U & value ); // (35) template < class T , class E , class U > constexpr bool operator < ( const T & value , const basic_result < U , E >& res ); // (36) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , const U & value ); // (37) template < class T , class E , class U > constexpr bool operator <= ( const T & value , const basic_result < U , E >& res ); // (38) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , const U & value ); // (39) template < class T , class E , class U > constexpr bool operator > ( const T & value , const basic_result < U , E >& res ); // (40) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , const U & value ); // (41) template < class T , class E , class U > constexpr bool operator >= ( const T & value , const basic_result < U , E >& res ); // (42) } Performs comparison operations on basic_result objects. 1-6) Compares two basic_result objects, lhs and rhs . The contained values are compared (using the corresponding operator of T and U or E and F ) only if the contents of lhs and rhs are either both success values or are both failure values. Otherwise, lhs is considered less than rhs if, and only if, rhs contains a success value and lhs contains failure value. lhs is considered less than rhs if, and only if, rhs contains a failure value and lhs contains success value. 7-18) Compares res with a ok . The values are compared (using the corresponding operator of E and F ) only if res contains a success value. Otherwise, res is considered less than ok . If the corresponding comparison expression between res.unwrap() and success value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 19-30) Compares res with a err . The values are compared (using the corresponding operator of T and U ) only if res contains a success value. Otherwise, res is considered greater than err . If the corresponding comparison expression between res.unwrap() and failure value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 31-42) Compares res with a value . Equivalent to (7-18) expression res ~ success(value) or success(value) ~ res . Parameters lhs , rhs , res - basic_result object to compare ok - a success object to compare err - a failure object to compare value - value to compare to the contained value Return value If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() == rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() == rhs.unwrap_err() Otherwise, if returns false . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() != rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() != rhs.unwrap_err() Otherwise, if returns true . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() < rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() < rhs.unwrap_err() Otherwise, if lhs.is_err() && rhs.is_ok() , returns true Otherwise, returns false . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() <= rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() <= rhs.unwrap_err() Otherwise, if lhs.is_err() && rhs.is_ok() , returns true Otherwise, returns false . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() > rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() > rhs.unwrap_err() Otherwise, if lhs.is_ok() && rhs.is_err() , returns true Otherwise, returns false . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() >= rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() >= rhs.unwrap_err() Otherwise, if lhs.is_ok() && rhs.is_err() , returns true Otherwise, returns false . Returns res.is_ok() ? res.unwrap() == ok.value : false . Returns res.is_ok() ? ok.value == res.unwrap() : false . Returns res.is_ok() ? res.unwrap() != ok.value : true . Returns res.is_ok() ? ok.value != res.unwrap() : true . Returns res.is_ok() ? res.unwrap() < ok.value : true . Returns res.is_ok() ? ok.value < res.unwrap() : false . Returns res.is_ok() ? res.unwrap() <= ok.value : true . Returns res.is_ok() ? ok.value <= res.unwrap() : false . Returns res.is_ok() ? res.unwrap() > ok.value : false . Returns res.is_ok() ? ok.value > res.unwrap() : true . Returns res.is_ok() ? res.unwrap() >= ok.value : false . Returns res.is_ok() ? ok.value >= res.unwrap() : true . Returns res.is_err() ? res.unwrap_err() == err.value : false . Returns res.is_err() ? err.value == res.unwrap_err() : false . Returns res.is_err() ? res.unwrap_err() != err.value : true . Returns res.is_err() ? err.value != res.unwrap_err() : true . Returns res.is_err() ? res.unwrap_err() < err.value : false . Returns res.is_err() ? err.value < res.unwrap_err() : true . Returns res.is_err() ? res.unwrap_err() <= err.value : false . Returns res.is_err() ? err.value <= res.unwrap_err() : true . Returns res.is_err() ? res.unwrap_err() > err.value : true . Returns res.is_err() ? err.value > res.unwrap_err() : false . Returns res.is_err() ? res.unwrap_err() >= err.value : false . Returns res.is_err() ? err.value >= res.unwrap_err() : true . Returns res == success(value) . Returns success(value) == res . Returns res != success(value) . Returns success(value) != res . Returns res < success(value) . Returns success(value) < res . Returns res <= success(value) . Returns success(value) <= res . Returns res > success(value) . Returns success(value) > res . Returns res >= success(value) . Returns success(value) >= res . Note err.value , ok.value : value is a private member of success or failure (actually, cannot access to it).","title":"Comparisons"},{"location":"result/comparisons/#operator_basic_result","text":"namespace mitama { // Compare two basic_result objects template < class T , class E , class U , class F > constexpr bool operator == ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (1) template < class T , class E , class U , class F > constexpr bool operator != ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (2) template < class T , class E , class U , class F > constexpr bool operator < ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (3) template < class T , class E , class U , class F > constexpr bool operator <= ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (4) template < class T , class E , class U , class F > constexpr bool operator > ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (5) template < class T , class E , class U , class F > constexpr bool operator >= ( const basic_result < T , E >& lhs , const basic_result < U , F >& rhs ); // (6) // Compare a basic_result object with a success(value) template < class T , class E , class U > constexpr bool operator == ( const basic_result < T , E >& res , success < U > const & ok ); // (7) template < class T , class E , class U > constexpr bool operator == ( success < T > const & ok , const basic_result < U , E >& res ); // (8) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , success < U > const & ok ); // (9) template < class T , class E , class U > constexpr bool operator != ( success < T > const & ok , const basic_result < U , E >& res ); // (10) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , success < U > const & ok ); // (11) template < class T , class E , class U > constexpr bool operator < ( success < T > const & ok , const basic_result < U , E >& res ); // (12) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , success < U > const & ok ); // (13) template < class T , class E , class U > constexpr bool operator <= ( success < T > const & ok , const basic_result < U , E >& res ); // (14) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , success < U > const & ok ); // (15) template < class T , class E , class U > constexpr bool operator > ( success < T > const & ok , const basic_result < U , E >& res ); // (16) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , success < U > const & ok ); // (17) template < class T , class E , class U > constexpr bool operator >= ( success < T > const & ok , const basic_result < U , E >& res ); // (18) // Compare a basic_result object with a failure(value) template < class T , class E , class F > constexpr bool operator == ( const basic_result < T , E >& res , failure < F > const & err ); // (19) template < class T , class E , class U > constexpr bool operator == ( failure < E > const & err , const basic_result < T , F >& res ); // (20) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , failure < F > const & err ); // (21) template < class T , class E , class U > constexpr bool operator != ( failure < E > const & err , const basic_result < T , F >& res ); // (22) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , failure < F > const & err ); // (23) template < class T , class E , class U > constexpr bool operator < ( failure < E > const & err , const basic_result < T , F >& res ); // (24) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , failure < F > const & err ); // (25) template < class T , class E , class U > constexpr bool operator <= ( failure < E > const & err , const basic_result < T , F >& res ); // (26) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , failure < F > const & err ); // (27) template < class T , class E , class U > constexpr bool operator > ( failure < E > const & err , const basic_result < T , F >& res ); // (28) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , failure < F > const & err ); // (29) template < class T , class E , class U > constexpr bool operator >= ( failure < E > const & err , const basic_result < T , F >& res ); // (30) // Compare a basic_result object with a T template < class T , class E , class U > constexpr bool operator == ( const basic_result < T , E >& res , const U & value ); // (31) template < class T , class E , class U > constexpr bool operator == ( const T & value , const basic_result < U , E >& res ); // (32) template < class T , class E , class U > constexpr bool operator != ( const basic_result < T , E >& res , const U & value ); // (33) template < class T , class E , class U > constexpr bool operator != ( const T & value , const basic_result < U , E >& res ); // (34) template < class T , class E , class U > constexpr bool operator < ( const basic_result < T , E >& res , const U & value ); // (35) template < class T , class E , class U > constexpr bool operator < ( const T & value , const basic_result < U , E >& res ); // (36) template < class T , class E , class U > constexpr bool operator <= ( const basic_result < T , E >& res , const U & value ); // (37) template < class T , class E , class U > constexpr bool operator <= ( const T & value , const basic_result < U , E >& res ); // (38) template < class T , class E , class U > constexpr bool operator > ( const basic_result < T , E >& res , const U & value ); // (39) template < class T , class E , class U > constexpr bool operator > ( const T & value , const basic_result < U , E >& res ); // (40) template < class T , class E , class U > constexpr bool operator >= ( const basic_result < T , E >& res , const U & value ); // (41) template < class T , class E , class U > constexpr bool operator >= ( const T & value , const basic_result < U , E >& res ); // (42) } Performs comparison operations on basic_result objects. 1-6) Compares two basic_result objects, lhs and rhs . The contained values are compared (using the corresponding operator of T and U or E and F ) only if the contents of lhs and rhs are either both success values or are both failure values. Otherwise, lhs is considered less than rhs if, and only if, rhs contains a success value and lhs contains failure value. lhs is considered less than rhs if, and only if, rhs contains a failure value and lhs contains success value. 7-18) Compares res with a ok . The values are compared (using the corresponding operator of E and F ) only if res contains a success value. Otherwise, res is considered less than ok . If the corresponding comparison expression between res.unwrap() and success value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 19-30) Compares res with a err . The values are compared (using the corresponding operator of T and U ) only if res contains a success value. Otherwise, res is considered greater than err . If the corresponding comparison expression between res.unwrap() and failure value is not well-formed, or if its result is not convertible to bool, the behavior is undefined. 31-42) Compares res with a value . Equivalent to (7-18) expression res ~ success(value) or success(value) ~ res . Parameters lhs , rhs , res - basic_result object to compare ok - a success object to compare err - a failure object to compare value - value to compare to the contained value Return value If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() == rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() == rhs.unwrap_err() Otherwise, if returns false . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() != rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() != rhs.unwrap_err() Otherwise, if returns true . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() < rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() < rhs.unwrap_err() Otherwise, if lhs.is_err() && rhs.is_ok() , returns true Otherwise, returns false . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() <= rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() <= rhs.unwrap_err() Otherwise, if lhs.is_err() && rhs.is_ok() , returns true Otherwise, returns false . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() > rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() > rhs.unwrap_err() Otherwise, if lhs.is_ok() && rhs.is_err() , returns true Otherwise, returns false . If lhs.is_ok() && rhs.is_ok() , returns lhs.unwrap() >= rhs.unwrap() . Otherwise, if lhs.is_err() && rhs.is_err() , returns lhs.unwrap_err() >= rhs.unwrap_err() Otherwise, if lhs.is_ok() && rhs.is_err() , returns true Otherwise, returns false . Returns res.is_ok() ? res.unwrap() == ok.value : false . Returns res.is_ok() ? ok.value == res.unwrap() : false . Returns res.is_ok() ? res.unwrap() != ok.value : true . Returns res.is_ok() ? ok.value != res.unwrap() : true . Returns res.is_ok() ? res.unwrap() < ok.value : true . Returns res.is_ok() ? ok.value < res.unwrap() : false . Returns res.is_ok() ? res.unwrap() <= ok.value : true . Returns res.is_ok() ? ok.value <= res.unwrap() : false . Returns res.is_ok() ? res.unwrap() > ok.value : false . Returns res.is_ok() ? ok.value > res.unwrap() : true . Returns res.is_ok() ? res.unwrap() >= ok.value : false . Returns res.is_ok() ? ok.value >= res.unwrap() : true . Returns res.is_err() ? res.unwrap_err() == err.value : false . Returns res.is_err() ? err.value == res.unwrap_err() : false . Returns res.is_err() ? res.unwrap_err() != err.value : true . Returns res.is_err() ? err.value != res.unwrap_err() : true . Returns res.is_err() ? res.unwrap_err() < err.value : false . Returns res.is_err() ? err.value < res.unwrap_err() : true . Returns res.is_err() ? res.unwrap_err() <= err.value : false . Returns res.is_err() ? err.value <= res.unwrap_err() : true . Returns res.is_err() ? res.unwrap_err() > err.value : true . Returns res.is_err() ? err.value > res.unwrap_err() : false . Returns res.is_err() ? res.unwrap_err() >= err.value : false . Returns res.is_err() ? err.value >= res.unwrap_err() : true . Returns res == success(value) . Returns success(value) == res . Returns res != success(value) . Returns success(value) != res . Returns res < success(value) . Returns success(value) < res . Returns res <= success(value) . Returns success(value) <= res . Returns res > success(value) . Returns success(value) > res . Returns res >= success(value) . Returns success(value) >= res . Note err.value , ok.value : value is a private member of success or failure (actually, cannot access to it).","title":"operator==, !=, &lt;, &lt;=, &gt;, &gt;=(basic_result)"},{"location":"result/intro/","text":"Introduction \u00b6 Definition of class basic_result \u00b6 enum class mutability : bool { mut = false , immut = true , }; template < mutability Mut > inline constexpr bool is_mut_v = ! static_cast < bool > ( Mut ); template < mutability , class = std :: monostate , // success type class = std :: monostate , // failure type class = decltype ( nullptr ) // for detection idiom > class basic_result ; Concepts \u00b6 Both of T and E must satisfy the following requirements: Complete type (if it is not reference type) or Reference Type (possibly incomplete type) Destructor upholds the no-throw exception-safety guarantee. result/mut_result the alias templates \u00b6 First (non-type) template parameter of basic_result is a value of enum class mutability for mutability control. The library provides two type synonyms of basic_result as follows: mut_result<T, E> stands for basic_result<mutability::mut, T, E> result<T, E> stands for basic_result<mutability::immut, T, E> You should use mut_result<T, E> if you want to resubstitute, result<T, E> do not provides assignment operators or mutable accessors. success/failure the in-place factory classes \u00b6 success_t and failure_t are in-place factory classes for basic_result . If you want to initialize result<T, E> with successful value of T , initialize with success_t<T> . result < int , std :: string > res = success_t { 42 }; Similarly, if you want to initialize result<T, E> with unsuccessful value of E , initialize with failure_t<E> . result < int , std :: string > res = failure_t { \"error\" }; However, using success and failure (factory methods) is recommended. result < int , std :: string > ok = success ( 42 ); result < int , std :: string > ng = failure ( \"error\" ); Result with reference types \u00b6 Using reference type \u00b6 // begin example #include <mitama/result/result.hpp> #include <string> #include <cassert> using namespace mitama ; int main () { int i = 1 ; mut_result < int & , std :: string &> res = success ( i ); res . unwrap () = 2 ; // get reference to `i`, and assign `2`. assert ( i == 2 ); } // end example Using reference of imcomplete type [since v8.0.0] \u00b6 // begin example #include <mitama/result/result.hpp> #include <string> #include <type_traits> #include <cassert> struct incomplete_type ; incomplete_type & get_incomplete_type (); template < class T , class = void > struct is_complete_type : std :: false_type {}; template < class T > struct is_complete_type < T , std :: void_t < decltype ( sizeof ( T )) >>: std :: true_type {}; using namespace mitama ; int main () { static_assert ( ! is_complete_type < incomplete_type >:: value ); [[ maybe_unused ]] result < incomplete_type &> res = success < incomplete_type &> ( get_incomplete_type ()); // use incomplete_type& for result } struct incomplete_type {}; incomplete_type & get_incomplete_type () { static incomplete_type obj = incomplete_type {}; return obj ; } // end example","title":"Result 101"},{"location":"result/intro/#introduction","text":"","title":"Introduction"},{"location":"result/intro/#definition_of_class_basic_result","text":"enum class mutability : bool { mut = false , immut = true , }; template < mutability Mut > inline constexpr bool is_mut_v = ! static_cast < bool > ( Mut ); template < mutability , class = std :: monostate , // success type class = std :: monostate , // failure type class = decltype ( nullptr ) // for detection idiom > class basic_result ;","title":"Definition of class basic_result"},{"location":"result/intro/#concepts","text":"Both of T and E must satisfy the following requirements: Complete type (if it is not reference type) or Reference Type (possibly incomplete type) Destructor upholds the no-throw exception-safety guarantee.","title":"Concepts"},{"location":"result/intro/#resultmut_result_the_alias_templates","text":"First (non-type) template parameter of basic_result is a value of enum class mutability for mutability control. The library provides two type synonyms of basic_result as follows: mut_result<T, E> stands for basic_result<mutability::mut, T, E> result<T, E> stands for basic_result<mutability::immut, T, E> You should use mut_result<T, E> if you want to resubstitute, result<T, E> do not provides assignment operators or mutable accessors.","title":"result/mut_result the alias templates"},{"location":"result/intro/#successfailure_the_in-place_factory_classes","text":"success_t and failure_t are in-place factory classes for basic_result . If you want to initialize result<T, E> with successful value of T , initialize with success_t<T> . result < int , std :: string > res = success_t { 42 }; Similarly, if you want to initialize result<T, E> with unsuccessful value of E , initialize with failure_t<E> . result < int , std :: string > res = failure_t { \"error\" }; However, using success and failure (factory methods) is recommended. result < int , std :: string > ok = success ( 42 ); result < int , std :: string > ng = failure ( \"error\" );","title":"success/failure the in-place factory classes"},{"location":"result/intro/#result_with_reference_types","text":"","title":"Result with reference types"},{"location":"result/intro/#using_reference_type","text":"// begin example #include <mitama/result/result.hpp> #include <string> #include <cassert> using namespace mitama ; int main () { int i = 1 ; mut_result < int & , std :: string &> res = success ( i ); res . unwrap () = 2 ; // get reference to `i`, and assign `2`. assert ( i == 2 ); } // end example","title":"Using reference type"},{"location":"result/intro/#using_reference_of_imcomplete_type_since_v800","text":"// begin example #include <mitama/result/result.hpp> #include <string> #include <type_traits> #include <cassert> struct incomplete_type ; incomplete_type & get_incomplete_type (); template < class T , class = void > struct is_complete_type : std :: false_type {}; template < class T > struct is_complete_type < T , std :: void_t < decltype ( sizeof ( T )) >>: std :: true_type {}; using namespace mitama ; int main () { static_assert ( ! is_complete_type < incomplete_type >:: value ); [[ maybe_unused ]] result < incomplete_type &> res = success < incomplete_type &> ( get_incomplete_type ()); // use incomplete_type& for result } struct incomplete_type {}; incomplete_type & get_incomplete_type () { static incomplete_type obj = incomplete_type {}; return obj ; } // end example","title":"Using reference of imcomplete type [since v8.0.0]"},{"location":"result/metafunctions/","text":"Meta functions \u00b6 is_result \u00b6 template < class > struct is_result : std :: false_type {}; template < class T , class E > struct is_result < result < T , E >> : std :: true_type {}; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ; is_result_with \u00b6 template < class , class ... > struct is_result_with : std :: false_type {}; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type {}; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type {}; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type {}; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"Meta Functions"},{"location":"result/metafunctions/#meta_functions","text":"","title":"Meta functions"},{"location":"result/metafunctions/#is_result","text":"template < class > struct is_result : std :: false_type {}; template < class T , class E > struct is_result < result < T , E >> : std :: true_type {}; template < class T > inline constexpr bool is_result_v = is_result < T >:: value ;","title":"is_result"},{"location":"result/metafunctions/#is_result_with","text":"template < class , class ... > struct is_result_with : std :: false_type {}; template < class T , class E > struct is_result_with < result < T , E > , success < T >> : std :: true_type {}; template < class T , class E > struct is_result_with < result < T , E > , failure < E >> : std :: true_type {}; template < class T , class E > struct is_result_with < result < T , E > , success < T > , failure < E >> : std :: true_type {}; template < class T , class ... Requires > inline constexpr bool is_result_with_v = is_result_with < T , Requires ... >:: value ;","title":"is_result_with"},{"location":"result/special_members/","text":"Constructors \u00b6 default constructor (deleted) [0/16] \u00b6 Default constructor is not permitted. explicit copy constructor for convertible basic_result [1/16] \u00b6 template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v<T, U> && is_nothrow_copy_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true and std::disjunction<std::negation<std::is_convertible<F, E>>, std::negation<std::is_convertible<U, T>>> is true. If is_trivially_copy_constructible_v<T, U> && is_trivially_copy_constructible_v<E, F> is true, this constructor shall be a constexpr constructor. non-explicit copy constructor for convertible basic_result [2/16] \u00b6 template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v<T, U> && is_nothrow_copy_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true, std::is_convertible<F, E> is true and, std::is_convertible<U, T>> is true. If is_trivially_copy_constructible_v<T, U> && is_trivially_copy_constructible_v<E, F> is true, this constructor shall be a constexpr constructor. explicit move constructor for convertible basic_result [3/16] \u00b6 template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v<T, U> && is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true and, std::disjunction<std::negation<std::is_convertible<F, E>>, std::negation<std::is_convertible<U, T>>> is true. If is_trivially_move_constructible_v<T, U> && is_trivially_move_constructible_v<E, F> is true, this constructor shall be a constexpr constructor. non-explicit copy constructor for convertible basic_result [4/16] \u00b6 template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v<T, U> && is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true, std::is_convertible<F, E> is true and, std::is_convertible<U, T>> is true. If is_trivially_move_constructible_v<T, U> && is_trivially_move_constructible_v<E, F> is true, this constructor shall be a constexpr constructor. non-explicit copy constructor from success [5/16] \u00b6 template < class U > basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true. explicit copy constructor from success [6/16] \u00b6 template < class U > explicit basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true. non-explicit move constructor from success [7/16] \u00b6 template < class U > basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true. explicit move constructor from success [8/16] \u00b6 template < class U > explicit basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true. non-explicit copy constructor from failure [9/16] \u00b6 template < class F > basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && is_convertible_v<F, E> is true. explicit copy constructor from failure [10/16] \u00b6 template < class F > explicit basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && !is_convertible_v<F, E> is true. non-explicit move constructor from failure [11/16] \u00b6 template < class F > basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && is_convertible_v<F, E> is true. explicit move constructor from failure [12/16] \u00b6 template < class F > explicit basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E>&& . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && !is_convertible_v<U, E> is true. emplace constructor for successful results [13/16] \u00b6 template < class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , Args && ... args ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (success<T>(std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, Args&&...> is true, this constructor shall be a nothrow constructor. Example using my_result = result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(success(std::tuple{1,1}))` emplace constructor for unsuccessful results [14/16] \u00b6 template < class ... Args > explicit basic_result :: basic_result ( in_place_err_t , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (failure<E>(std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, Args&&...> is true, this constructor shall be a nothrow constructor. Example using my_result = result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // failure(\"aaaaa\") emplace constructor with initializer_list for successful results [15/16] \u00b6 template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (success<T>(il, std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = result < std :: vector < int > , std :: string > ; auto res = my_result ( in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // success([1,2,3,4]) emplace constructor with initializer_list for unsuccessful results [16/16] \u00b6 template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (failure<E>(il, std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = result < std :: string , std :: vector < int >> ; auto res = my_result ( in_place_err , { 1 , 2 , 3 , 4 }); // failure([1,2,3,4]) Assignment operators \u00b6 copy assignment operator [\u2159] \u00b6 template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F > const & res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable. move assignment operator [2/6] \u00b6 template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F >&& res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable. copy assignment operator for success [3/6] \u00b6 template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U > const & _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable. move assignment operator for success [4/6] \u00b6 template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U >&& _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable. copy assignment operator for failure [\u215a] \u00b6 template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F > const & _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable. move assignment operator for failure [6/6] \u00b6 template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F >&& _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"Special Members"},{"location":"result/special_members/#constructors","text":"","title":"Constructors"},{"location":"result/special_members/#default_constructor_deleted_016","text":"Default constructor is not permitted.","title":"default constructor (deleted) [0/16]"},{"location":"result/special_members/#explicit_copy_constructor_for_convertible_basic_result_116","text":"template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v<T, U> && is_nothrow_copy_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true and std::disjunction<std::negation<std::is_convertible<F, E>>, std::negation<std::is_convertible<U, T>>> is true. If is_trivially_copy_constructible_v<T, U> && is_trivially_copy_constructible_v<E, F> is true, this constructor shall be a constexpr constructor.","title":"explicit copy constructor for convertible basic_result [1/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_for_convertible_basic_result_216","text":"template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F > const & res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by copy. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_copy_constructible_v<T, U> && is_nothrow_copy_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true, std::is_convertible<F, E> is true and, std::is_convertible<U, T>> is true. If is_trivially_copy_constructible_v<T, U> && is_trivially_copy_constructible_v<E, F> is true, this constructor shall be a constexpr constructor.","title":"non-explicit copy constructor for convertible basic_result [2/16]"},{"location":"result/special_members/#explicit_move_constructor_for_convertible_basic_result_316","text":"template < mutability _ , class U , class F > explicit constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v<T, U> && is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true and, std::disjunction<std::negation<std::is_convertible<F, E>>, std::negation<std::is_convertible<U, T>>> is true. If is_trivially_move_constructible_v<T, U> && is_trivially_move_constructible_v<E, F> is true, this constructor shall be a constexpr constructor.","title":"explicit move constructor for convertible basic_result [3/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_for_convertible_basic_result_416","text":"template < mutability _ , class U , class F > constexpr ( see below ) basic_result :: basic_result ( basic_result < _ , U , F >&& res ) noexcept ( see below ) Effects Initialize a retention variant from what res holds by move. Exceptions Any exception thrown by the selected constructor of T or E . If is_nothrow_move_constructible_v<T, U> && is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless std::is_constructible<T, U> is true, std::is_constructible<E, F> is true, std::is_convertible<F, E> is true and, std::is_convertible<U, T>> is true. If is_trivially_move_constructible_v<T, U> && is_trivially_move_constructible_v<E, F> is true, this constructor shall be a constexpr constructor.","title":"non-explicit copy constructor for convertible basic_result [4/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_from_success_516","text":"template < class U > basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true.","title":"non-explicit copy constructor from success [5/16]"},{"location":"result/special_members/#explicit_copy_constructor_from_success_616","text":"template < class U > explicit basic_result :: basic_result ( success < U > const & ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true.","title":"explicit copy constructor from success [6/16]"},{"location":"result/special_members/#non-explicit_move_constructor_from_success_716","text":"template < class U > basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && is_convertible_v<U, T> is true.","title":"non-explicit move constructor from success [7/16]"},{"location":"result/special_members/#explicit_move_constructor_from_success_816","text":"template < class U > explicit basic_result :: basic_result ( success < U >&& ok ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type success<T> . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, U> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<T, U> && !is_convertible_v<U, T> is true.","title":"explicit move constructor from success [8/16]"},{"location":"result/special_members/#non-explicit_copy_constructor_from_failure_916","text":"template < class F > basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && is_convertible_v<F, E> is true.","title":"non-explicit copy constructor from failure [9/16]"},{"location":"result/special_members/#explicit_copy_constructor_from_failure_1016","text":"template < class F > explicit basic_result :: basic_result ( failure < F > const & err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && !is_convertible_v<F, E> is true.","title":"explicit copy constructor from failure [10/16]"},{"location":"result/special_members/#non-explicit_move_constructor_from_failure_1116","text":"template < class F > basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E> . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, F> && is_convertible_v<F, E> is true.","title":"non-explicit move constructor from failure [11/16]"},{"location":"result/special_members/#explicit_move_constructor_from_failure_1216","text":"template < class F > explicit basic_result :: basic_result ( failure < F >&& err ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type failure<E>&& . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, F> is true, this constructor shall be a nothrow constructor. Remarks This constructor shall not participate in overload resolution unless is_constructible_v<E, U> && !is_convertible_v<U, E> is true.","title":"explicit move constructor from failure [12/16]"},{"location":"result/special_members/#emplace_constructor_for_successful_results_1316","text":"template < class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , Args && ... args ) noexcept ( see below ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (success<T>(std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of T . If is_nothrow_move_constructible_v<T, Args&&...> is true, this constructor shall be a nothrow constructor. Example using my_result = result < std :: tuple < int , int > , std :: string > ; auto res = my_result ( mitama :: in_place_ok , 1 , 1 ); // same as `my_result(success(std::tuple{1,1}))`","title":"emplace constructor for successful results [13/16]"},{"location":"result/special_members/#emplace_constructor_for_unsuccessful_results_1416","text":"template < class ... Args > explicit basic_result :: basic_result ( in_place_err_t , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (failure<E>(std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of E . If is_nothrow_move_constructible_v<E, Args&&...> is true, this constructor shall be a nothrow constructor. Example using my_result = result < int , std :: string > ; auto res = my_result ( mitama :: in_place_err , 'a' , 5 ); // failure(\"aaaaa\")","title":"emplace constructor for unsuccessful results [14/16]"},{"location":"result/special_members/#emplace_constructor_with_initializer_list_for_successful_results_1516","text":"template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (success<T>(il, std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of T. Example using my_result = result < std :: vector < int > , std :: string > ; auto res = my_result ( in_place_ok , { 1 , 2 , 3 , 4 }, std :: allocator < int > ()); // success([1,2,3,4])","title":"emplace constructor with initializer_list for successful results [15/16]"},{"location":"result/special_members/#emplace_constructor_with_initializer_list_for_unsuccessful_results_1616","text":"template < class U , class ... Args > explicit basic_result :: basic_result ( in_place_ok_t , std :: initializer_list < U > il , Args && ... args ) Effects Initializes the contained variant as if in-place-initializing an object of type with expression (failure<E>(il, std::forward<Args>(args)...)) . Exceptions Any exception thrown by the selected constructor of E . Example using my_result = result < std :: string , std :: vector < int >> ; auto res = my_result ( in_place_err , { 1 , 2 , 3 , 4 }); // failure([1,2,3,4])","title":"emplace constructor with initializer_list for unsuccessful results [16/16]"},{"location":"result/special_members/#assignment_operators","text":"","title":"Assignment operators"},{"location":"result/special_members/#copy_assignment_operator_16","text":"template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F > const & res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator [1/6]"},{"location":"result/special_members/#move_assignment_operator_26","text":"template < mutability _ , class U , class F , where < std :: is_constructible < T , U > , std :: is_constructible < E , F > > = required > constexpr basic_result & basic_result :: operator = ( basic_result < _ , U , F >&& res ) Effects Destroy the contained value and replace it with the one contained in res . Exceptions Any exception thrown by the selected constructor of T or E . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator [2/6]"},{"location":"result/special_members/#copy_assignment_operator_for_success_36","text":"template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U > const & _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator for success [3/6]"},{"location":"result/special_members/#move_assignment_operator_for_success_46","text":"template < class U , where < std :: is_constructible < T , U >> = required > constexpr basic_result & basic_result :: operator = ( success < U >&& _ok ) Effects Destroy the contained value and replace it with the successful value _ok . Exceptions Any exception thrown by the selected constructor of T . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator for success [4/6]"},{"location":"result/special_members/#copy_assignment_operator_for_failure_56","text":"template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F > const & _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"copy assignment operator for failure [5/6]"},{"location":"result/special_members/#move_assignment_operator_for_failure_66","text":"template < class F , where < std :: is_constructible < E , F >> = required > constexpr basic_result & basic_result :: operator = ( failure < F >&& _err ) Effects Destroy the contained value and replace it with the unsuccessful value _err . Exceptions Any exception thrown by the selected constructor of E . Remark This operator fails by static assertion unless self is mutable.","title":"move assignment operator for failure [6/6]"},{"location":"thiserror/thiserror/","text":"thiserror 101 \u00b6 thiserror is a library that makes it easy to write domain-specific error types. We can embed the reason for the error directly into the type. For example, if you want to write data_store_error , you can write the following: #include <mitama/thiserror/thiserror.hpp> class data_store_error { template < mitama :: thiserror :: fixed_string S , class ... T > using error = mitama :: thiserror :: error < S , T ... > ; public : using disconnect = error < \"data store disconnected\" > ; using redaction = error < \"for key `{0}` isn't available\" , std :: string > ; using invalid_header = error < \"(expected {0}, found {1})\" , std :: string , std :: string > ; using unknown = error < \"unknown data store error\" > ; }; The first template argument of mitama::thiserror::error is embedded with a format string. The format string should be a string compliant with {fmt} , check the documentation if you need it. The second template argument onwards is a list of formattable arguments. mitama::thiserror::error inherits from anyhow::error , so it can be used together with anyhow. The factory function anyhow::failure is used to create a shared_ptr for thiserror::error . anyhow :: result < int > data = anyhow :: failure < data_store_error :: disconnect > (); Examples: // begin example #include <mitama/result/result.hpp> #include <mitama/result/result_io.hpp> #include <mitama/anyhow/anyhow.hpp> #include <mitama/thiserror/thiserror.hpp> namespace anyhow = mitama :: anyhow ; using namespace std :: literals ; class data_store_error { template < mitama :: thiserror :: fixed_string S , class ... T > using error = mitama :: thiserror :: error < S , T ... > ; public : using disconnect = error < \"data store disconnected\" > ; using redaction = error < \"for key `{0}` isn't available\" , std :: string > ; using invalid_header = error < \"(expected {0}, found {1})\" , std :: string , std :: string > ; using unknown = error < \"unknown data store error\" > ; }; int main () { anyhow :: result < int > data = anyhow :: failure < data_store_error :: redaction > ( \"invalid key\" ); auto res = data . with_context ([] { return anyhow :: anyhow ( \"data store failed.\" s ); }); }","title":"thiserror 101"},{"location":"thiserror/thiserror/#thiserror_101","text":"thiserror is a library that makes it easy to write domain-specific error types. We can embed the reason for the error directly into the type. For example, if you want to write data_store_error , you can write the following: #include <mitama/thiserror/thiserror.hpp> class data_store_error { template < mitama :: thiserror :: fixed_string S , class ... T > using error = mitama :: thiserror :: error < S , T ... > ; public : using disconnect = error < \"data store disconnected\" > ; using redaction = error < \"for key `{0}` isn't available\" , std :: string > ; using invalid_header = error < \"(expected {0}, found {1})\" , std :: string , std :: string > ; using unknown = error < \"unknown data store error\" > ; }; The first template argument of mitama::thiserror::error is embedded with a format string. The format string should be a string compliant with {fmt} , check the documentation if you need it. The second template argument onwards is a list of formattable arguments. mitama::thiserror::error inherits from anyhow::error , so it can be used together with anyhow. The factory function anyhow::failure is used to create a shared_ptr for thiserror::error . anyhow :: result < int > data = anyhow :: failure < data_store_error :: disconnect > (); Examples: // begin example #include <mitama/result/result.hpp> #include <mitama/result/result_io.hpp> #include <mitama/anyhow/anyhow.hpp> #include <mitama/thiserror/thiserror.hpp> namespace anyhow = mitama :: anyhow ; using namespace std :: literals ; class data_store_error { template < mitama :: thiserror :: fixed_string S , class ... T > using error = mitama :: thiserror :: error < S , T ... > ; public : using disconnect = error < \"data store disconnected\" > ; using redaction = error < \"for key `{0}` isn't available\" , std :: string > ; using invalid_header = error < \"(expected {0}, found {1})\" , std :: string , std :: string > ; using unknown = error < \"unknown data store error\" > ; }; int main () { anyhow :: result < int > data = anyhow :: failure < data_store_error :: redaction > ( \"invalid key\" ); auto res = data . with_context ([] { return anyhow :: anyhow ( \"data store failed.\" s ); }); }","title":"thiserror 101"}]}